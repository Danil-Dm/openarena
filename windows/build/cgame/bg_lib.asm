code
proc swapfunc 24 0
file "../../../code/game/bg_lib.c"
line 76
;1://
;2://
;3:// bg_lib,c -- standard C library replacement routines used by code
;4:// compiled for the virtual machine
;5:
;6:#ifdef Q3_VM
;7:
;8:#include "../qcommon/q_shared.h"
;9:
;10:/*-
;11: * Copyright (c) 1992, 1993
;12: *	The Regents of the University of California.  All rights reserved.
;13: *
;14: * Redistribution and use in source and binary forms, with or without
;15: * modification, are permitted provided that the following conditions
;16: * are met:
;17: * 1. Redistributions of source code must retain the above copyright
;18: *    notice, this list of conditions and the following disclaimer.
;19: * 2. Redistributions in binary form must reproduce the above copyright
;20: *    notice, this list of conditions and the following disclaimer in the
;21: *    documentation and/or other materials provided with the distribution.
;22: * 3. Neither the name of the University nor the names of its contributors
;23: *    may be used to endorse or promote products derived from this software
;24: *    without specific prior written permission.
;25: *
;26: * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
;27: * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;28: * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;29: * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
;30: * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
;31: * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
;32: * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
;33: * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
;34: * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
;35: * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
;36: * SUCH DAMAGE.
;37: */
;38:
;39:#include "bg_lib.h"
;40:
;41:#if defined(LIBC_SCCS) && !defined(lint)
;42:#if 0
;43:static char sccsid[] = "@(#)qsort.c	8.1 (Berkeley) 6/4/93";
;44:#endif
;45:static const char rcsid[] =
;46:#endif /* LIBC_SCCS and not lint */
;47:
;48:		static char* med3(char *, char *, char *, cmp_t *);
;49:static void swapfunc(char *, char *, int, int);
;50:
;51:#ifndef min
;52:#define min(a, b) ((a) < (b) ? (a) : (b))
;53:#endif
;54:
;55:/*
;56: * Qsort routine from Bentley & McIlroy's "Engineering a Sort Function".
;57: */
;58:#define swapcode(TYPE, parmi, parmj, n) {   \
;59:	long i = (n) / sizeof (TYPE);    \
;60:	register TYPE *pi = (TYPE *) (parmi);   \
;61:	register TYPE *pj = (TYPE *) (parmj);   \
;62:	do {       \
;63:		register TYPE t = *pi;  \
;64:		*pi++ = *pj;    \
;65:		*pj++ = t;    \
;66:        } while (--i > 0);    \
;67:}
;68:
;69:#define SWAPINIT(a, es) swaptype = ((char *)a - (char *)0) % sizeof(long) || \
;70:	es % sizeof(long) ? 2 : es == sizeof(long)? 0 : 1;
;71:
;72:static void
;73:swapfunc(a, b, n, swaptype)
;74:char *a, *b;
;75:int n, swaptype;
;76:{
line 77
;77:	if (swaptype <= 1)
ADDRFP4 12
INDIRI4
CNSTI4 1
GTI4 $24
line 78
;78:		swapcode(long, a, b, n)
ADDRLP4 8
ADDRFP4 8
INDIRI4
CVIU4 4
CNSTI4 2
RSHU4
CVUI4 4
ASGNI4
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
LABELV $26
ADDRLP4 12
ADDRLP4 0
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 16
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 16
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
ADDRLP4 16
INDIRP4
ADDRLP4 4
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 20
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 20
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
ADDRLP4 20
INDIRP4
ADDRLP4 12
INDIRI4
ASGNI4
LABELV $27
ADDRLP4 12
ADDRLP4 8
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRLP4 8
ADDRLP4 12
INDIRI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
GTI4 $26
ADDRGP4 $25
JUMPV
LABELV $24
line 80
;79:	else
;80:		swapcode(char, a, b, n)
ADDRLP4 8
ADDRFP4 8
INDIRI4
CVIU4 4
CVUI4 4
ASGNI4
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
LABELV $29
ADDRLP4 12
ADDRLP4 0
INDIRP4
INDIRI1
ASGNI1
ADDRLP4 16
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 16
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 16
INDIRP4
ADDRLP4 4
INDIRP4
INDIRI1
ASGNI1
ADDRLP4 20
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 20
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 20
INDIRP4
ADDRLP4 12
INDIRI1
ASGNI1
LABELV $30
ADDRLP4 12
ADDRLP4 8
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRLP4 8
ADDRLP4 12
INDIRI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
GTI4 $29
LABELV $25
line 81
;81:	}
LABELV $23
endproc swapfunc 24 0
proc med3 40 8
line 97
;82:
;83:#define swap(a, b)     \
;84:	if (swaptype == 0) {    \
;85:		long t = *(long *)(a);   \
;86:		*(long *)(a) = *(long *)(b);  \
;87:		*(long *)(b) = t;   \
;88:	} else      \
;89:		swapfunc(a, b, es, swaptype)
;90:
;91:#define vecswap(a, b, n)  if ((n) > 0) swapfunc(a, b, n, swaptype)
;92:
;93:static char *
;94:med3(a, b, c, cmp)
;95:char *a, *b, *c;
;96:cmp_t *cmp;
;97:{
line 98
;98:	return cmp(a, b) < 0 ?
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 20
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 0
GEI4 $38
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 24
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 0
GEI4 $40
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
ADDRGP4 $41
JUMPV
LABELV $40
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 28
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 0
GEI4 $42
ADDRLP4 8
ADDRFP4 8
INDIRP4
ASGNP4
ADDRGP4 $43
JUMPV
LABELV $42
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $43
ADDRLP4 4
ADDRLP4 8
INDIRP4
ASGNP4
LABELV $41
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
ADDRGP4 $39
JUMPV
LABELV $38
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 32
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 0
LEI4 $44
ADDRLP4 12
ADDRFP4 4
INDIRP4
ASGNP4
ADDRGP4 $45
JUMPV
LABELV $44
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 36
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 36
INDIRI4
CNSTI4 0
GEI4 $46
ADDRLP4 16
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $47
JUMPV
LABELV $46
ADDRLP4 16
ADDRFP4 8
INDIRP4
ASGNP4
LABELV $47
ADDRLP4 12
ADDRLP4 16
INDIRP4
ASGNP4
LABELV $45
ADDRLP4 0
ADDRLP4 12
INDIRP4
ASGNP4
LABELV $39
ADDRLP4 0
INDIRP4
RETP4
LABELV $32
endproc med3 40 8
export qsort
proc qsort 104 16
line 108
;99:			(cmp(b, c) < 0 ? b : (cmp(a, c) < 0 ? c : a))
;100:			: (cmp(b, c) > 0 ? b : (cmp(a, c) < 0 ? a : c));
;101:}
;102:
;103:void
;104:qsort(a, n, es, cmp)
;105:void *a;
;106:size_t n, es;
;107:cmp_t *cmp;
;108:{
LABELV $49
line 113
;109:	char *pa, *pb, *pc, *pd, *pl, *pm, *pn;
;110:	int d, r, swaptype, swap_cnt;
;111:
;112:loop:
;113:	SWAPINIT(a, es);
ADDRLP4 52
CNSTU4 3
ASGNU4
ADDRLP4 56
CNSTU4 0
ASGNU4
ADDRFP4 0
INDIRP4
CVPU4 4
CVUI4 4
CVIU4 4
ADDRLP4 52
INDIRU4
BANDU4
ADDRLP4 56
INDIRU4
NEU4 $54
ADDRFP4 8
INDIRI4
CVIU4 4
ADDRLP4 52
INDIRU4
BANDU4
ADDRLP4 56
INDIRU4
EQU4 $52
LABELV $54
ADDRLP4 44
CNSTI4 2
ASGNI4
ADDRGP4 $53
JUMPV
LABELV $52
ADDRFP4 8
INDIRI4
CVIU4 4
CNSTU4 4
NEU4 $55
ADDRLP4 48
CNSTI4 0
ASGNI4
ADDRGP4 $56
JUMPV
LABELV $55
ADDRLP4 48
CNSTI4 1
ASGNI4
LABELV $56
ADDRLP4 44
ADDRLP4 48
INDIRI4
ASGNI4
LABELV $53
ADDRLP4 16
ADDRLP4 44
INDIRI4
ASGNI4
line 114
;114:	swap_cnt = 0;
ADDRLP4 28
CNSTI4 0
ASGNI4
line 115
;115:	if (n < 7) {
ADDRFP4 4
INDIRI4
CNSTI4 7
GEI4 $57
line 116
;116:		for (pm = (char *) a + es; pm < (char *) a + n * es; pm += es)
ADDRLP4 32
ADDRFP4 8
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
ASGNP4
ADDRGP4 $62
JUMPV
LABELV $59
line 117
;117:			for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;
ADDRLP4 0
ADDRLP4 32
INDIRP4
ASGNP4
ADDRGP4 $66
JUMPV
LABELV $63
line 119
;118:					pl -= es)
;119:				swap(pl, pl - es);
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $67
ADDRLP4 60
ADDRLP4 0
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 0
INDIRP4
ADDRLP4 0
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
INDIRI4
ASGNI4
ADDRLP4 0
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ADDRLP4 60
INDIRI4
ASGNI4
ADDRGP4 $68
JUMPV
LABELV $67
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 64
ADDRFP4 8
INDIRI4
ASGNI4
ADDRLP4 0
INDIRP4
ADDRLP4 64
INDIRI4
SUBP4
ARGP4
ADDRLP4 64
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 swapfunc
CALLV
pop
LABELV $68
LABELV $64
line 118
ADDRLP4 0
ADDRLP4 0
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ASGNP4
LABELV $66
line 117
ADDRLP4 0
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
LEU4 $69
ADDRLP4 0
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 72
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 72
INDIRI4
CNSTI4 0
GTI4 $63
LABELV $69
LABELV $60
line 116
ADDRLP4 32
ADDRFP4 8
INDIRI4
ADDRLP4 32
INDIRP4
ADDP4
ASGNP4
LABELV $62
ADDRLP4 32
INDIRP4
CVPU4 4
ADDRFP4 4
INDIRI4
ADDRFP4 8
INDIRI4
MULI4
ADDRFP4 0
INDIRP4
ADDP4
CVPU4 4
LTU4 $59
line 120
;120:		return;
ADDRGP4 $48
JUMPV
LABELV $57
line 122
;121:	}
;122:	pm = (char *) a + (n / 2) * es;
ADDRLP4 32
ADDRFP4 4
INDIRI4
CNSTI4 2
DIVI4
ADDRFP4 8
INDIRI4
MULI4
ADDRFP4 0
INDIRP4
ADDP4
ASGNP4
line 123
;123:	if (n > 7) {
ADDRFP4 4
INDIRI4
CNSTI4 7
LEI4 $70
line 124
;124:		pl = a;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
line 125
;125:		pn = (char *) a + (n - 1) * es;
ADDRLP4 36
ADDRFP4 4
INDIRI4
CNSTI4 1
SUBI4
ADDRFP4 8
INDIRI4
MULI4
ADDRFP4 0
INDIRP4
ADDP4
ASGNP4
line 126
;126:		if (n > 40) {
ADDRFP4 4
INDIRI4
CNSTI4 40
LEI4 $72
line 127
;127:			d = (n / 8) * es;
ADDRLP4 40
ADDRFP4 4
INDIRI4
CNSTI4 8
DIVI4
ADDRFP4 8
INDIRI4
MULI4
ASGNI4
line 128
;128:			pl = med3(pl, pl + d, pl + 2 * d, cmp);
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 64
ADDRLP4 40
INDIRI4
ASGNI4
ADDRLP4 64
INDIRI4
ADDRLP4 0
INDIRP4
ADDP4
ARGP4
ADDRLP4 64
INDIRI4
CNSTI4 1
LSHI4
ADDRLP4 0
INDIRP4
ADDP4
ARGP4
ADDRFP4 12
INDIRP4
ARGP4
ADDRLP4 68
ADDRGP4 med3
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 68
INDIRP4
ASGNP4
line 129
;129:			pm = med3(pm - d, pm, pm + d, cmp);
ADDRLP4 76
ADDRLP4 40
INDIRI4
ASGNI4
ADDRLP4 32
INDIRP4
ADDRLP4 76
INDIRI4
SUBP4
ARGP4
ADDRLP4 32
INDIRP4
ARGP4
ADDRLP4 76
INDIRI4
ADDRLP4 32
INDIRP4
ADDP4
ARGP4
ADDRFP4 12
INDIRP4
ARGP4
ADDRLP4 80
ADDRGP4 med3
CALLP4
ASGNP4
ADDRLP4 32
ADDRLP4 80
INDIRP4
ASGNP4
line 130
;130:			pn = med3(pn - 2 * d, pn - d, pn, cmp);
ADDRLP4 88
ADDRLP4 40
INDIRI4
ASGNI4
ADDRLP4 36
INDIRP4
ADDRLP4 88
INDIRI4
CNSTI4 1
LSHI4
SUBP4
ARGP4
ADDRLP4 36
INDIRP4
ADDRLP4 88
INDIRI4
SUBP4
ARGP4
ADDRLP4 36
INDIRP4
ARGP4
ADDRFP4 12
INDIRP4
ARGP4
ADDRLP4 92
ADDRGP4 med3
CALLP4
ASGNP4
ADDRLP4 36
ADDRLP4 92
INDIRP4
ASGNP4
line 131
;131:		}
LABELV $72
line 132
;132:		pm = med3(pl, pm, pn, cmp);
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 32
INDIRP4
ARGP4
ADDRLP4 36
INDIRP4
ARGP4
ADDRFP4 12
INDIRP4
ARGP4
ADDRLP4 60
ADDRGP4 med3
CALLP4
ASGNP4
ADDRLP4 32
ADDRLP4 60
INDIRP4
ASGNP4
line 133
;133:	}
LABELV $70
line 134
;134:	swap(a, pm);
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $74
ADDRLP4 60
ADDRFP4 0
INDIRP4
INDIRI4
ASGNI4
ADDRFP4 0
INDIRP4
ADDRLP4 32
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 32
INDIRP4
ADDRLP4 60
INDIRI4
ASGNI4
ADDRGP4 $75
JUMPV
LABELV $74
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 32
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 swapfunc
CALLV
pop
LABELV $75
line 135
;135:	pa = pb = (char *) a + es;
ADDRLP4 60
ADDRFP4 8
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 60
INDIRP4
ASGNP4
ADDRLP4 20
ADDRLP4 60
INDIRP4
ASGNP4
line 137
;136:
;137:	pc = pd = (char *) a + (n - 1) * es;
ADDRLP4 64
ADDRFP4 4
INDIRI4
CNSTI4 1
SUBI4
ADDRFP4 8
INDIRI4
MULI4
ADDRFP4 0
INDIRP4
ADDP4
ASGNP4
ADDRLP4 24
ADDRLP4 64
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 64
INDIRP4
ASGNP4
line 138
;138:	for (;;) {
ADDRGP4 $81
JUMPV
LABELV $80
line 139
;139:		while (pb <= pc && (r = cmp(pb, a)) <= 0) {
line 140
;140:			if (r == 0) {
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $83
line 141
;141:				swap_cnt = 1;
ADDRLP4 28
CNSTI4 1
ASGNI4
line 142
;142:				swap(pa, pb);
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $85
ADDRLP4 68
ADDRLP4 20
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 20
INDIRP4
ADDRLP4 4
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 4
INDIRP4
ADDRLP4 68
INDIRI4
ASGNI4
ADDRGP4 $86
JUMPV
LABELV $85
ADDRLP4 20
INDIRP4
ARGP4
ADDRLP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 swapfunc
CALLV
pop
LABELV $86
line 143
;143:				pa += es;
ADDRLP4 20
ADDRFP4 8
INDIRI4
ADDRLP4 20
INDIRP4
ADDP4
ASGNP4
line 144
;144:			}
LABELV $83
line 145
;145:			pb += es;
ADDRLP4 4
ADDRFP4 8
INDIRI4
ADDRLP4 4
INDIRP4
ADDP4
ASGNP4
line 146
;146:		}
LABELV $81
line 139
ADDRLP4 4
INDIRP4
CVPU4 4
ADDRLP4 8
INDIRP4
CVPU4 4
GTU4 $87
ADDRLP4 4
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 72
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 72
INDIRI4
ASGNI4
ADDRLP4 72
INDIRI4
CNSTI4 0
LEI4 $80
LABELV $87
ADDRGP4 $89
JUMPV
LABELV $88
line 147
;147:		while (pb <= pc && (r = cmp(pc, a)) >= 0) {
line 148
;148:			if (r == 0) {
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $91
line 149
;149:				swap_cnt = 1;
ADDRLP4 28
CNSTI4 1
ASGNI4
line 150
;150:				swap(pc, pd);
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $93
ADDRLP4 76
ADDRLP4 8
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 8
INDIRP4
ADDRLP4 24
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 24
INDIRP4
ADDRLP4 76
INDIRI4
ASGNI4
ADDRGP4 $94
JUMPV
LABELV $93
ADDRLP4 8
INDIRP4
ARGP4
ADDRLP4 24
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 swapfunc
CALLV
pop
LABELV $94
line 151
;151:				pd -= es;
ADDRLP4 24
ADDRLP4 24
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ASGNP4
line 152
;152:			}
LABELV $91
line 153
;153:			pc -= es;
ADDRLP4 8
ADDRLP4 8
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ASGNP4
line 154
;154:		}
LABELV $89
line 147
ADDRLP4 4
INDIRP4
CVPU4 4
ADDRLP4 8
INDIRP4
CVPU4 4
GTU4 $95
ADDRLP4 8
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 80
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 80
INDIRI4
ASGNI4
ADDRLP4 80
INDIRI4
CNSTI4 0
GEI4 $88
LABELV $95
line 155
;155:		if (pb > pc)
ADDRLP4 4
INDIRP4
CVPU4 4
ADDRLP4 8
INDIRP4
CVPU4 4
LEU4 $96
line 156
;156:			break;
ADDRGP4 $78
JUMPV
LABELV $96
line 157
;157:		swap(pb, pc);
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $98
ADDRLP4 84
ADDRLP4 4
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 4
INDIRP4
ADDRLP4 8
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 8
INDIRP4
ADDRLP4 84
INDIRI4
ASGNI4
ADDRGP4 $99
JUMPV
LABELV $98
ADDRLP4 4
INDIRP4
ARGP4
ADDRLP4 8
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 swapfunc
CALLV
pop
LABELV $99
line 158
;158:		swap_cnt = 1;
ADDRLP4 28
CNSTI4 1
ASGNI4
line 159
;159:		pb += es;
ADDRLP4 4
ADDRFP4 8
INDIRI4
ADDRLP4 4
INDIRP4
ADDP4
ASGNP4
line 160
;160:		pc -= es;
ADDRLP4 8
ADDRLP4 8
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ASGNP4
line 161
;161:	}
line 138
ADDRGP4 $81
JUMPV
LABELV $78
line 162
;162:	if (swap_cnt == 0) { /* Switch to insertion sort */
ADDRLP4 28
INDIRI4
CNSTI4 0
NEI4 $100
line 163
;163:		for (pm = (char *) a + es; pm < (char *) a + n * es; pm += es)
ADDRLP4 32
ADDRFP4 8
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
ASGNP4
ADDRGP4 $105
JUMPV
LABELV $102
line 164
;164:			for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;
ADDRLP4 0
ADDRLP4 32
INDIRP4
ASGNP4
ADDRGP4 $109
JUMPV
LABELV $106
line 166
;165:					pl -= es)
;166:				swap(pl, pl - es);
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $110
ADDRLP4 68
ADDRLP4 0
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 0
INDIRP4
ADDRLP4 0
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
INDIRI4
ASGNI4
ADDRLP4 0
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ADDRLP4 68
INDIRI4
ASGNI4
ADDRGP4 $111
JUMPV
LABELV $110
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 72
ADDRFP4 8
INDIRI4
ASGNI4
ADDRLP4 0
INDIRP4
ADDRLP4 72
INDIRI4
SUBP4
ARGP4
ADDRLP4 72
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 swapfunc
CALLV
pop
LABELV $111
LABELV $107
line 165
ADDRLP4 0
ADDRLP4 0
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ASGNP4
LABELV $109
line 164
ADDRLP4 0
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
LEU4 $112
ADDRLP4 0
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 80
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 80
INDIRI4
CNSTI4 0
GTI4 $106
LABELV $112
LABELV $103
line 163
ADDRLP4 32
ADDRFP4 8
INDIRI4
ADDRLP4 32
INDIRP4
ADDP4
ASGNP4
LABELV $105
ADDRLP4 32
INDIRP4
CVPU4 4
ADDRFP4 4
INDIRI4
ADDRFP4 8
INDIRI4
MULI4
ADDRFP4 0
INDIRP4
ADDP4
CVPU4 4
LTU4 $102
line 167
;167:		return;
ADDRGP4 $48
JUMPV
LABELV $100
line 170
;168:	}
;169:
;170:	pn = (char *) a + n * es;
ADDRLP4 36
ADDRFP4 4
INDIRI4
ADDRFP4 8
INDIRI4
MULI4
ADDRFP4 0
INDIRP4
ADDP4
ASGNP4
line 171
;171:	r = min(pa - (char *) a, pb - pa);
ADDRLP4 72
ADDRLP4 20
INDIRP4
CVPU4 4
ASGNU4
ADDRLP4 72
INDIRU4
ADDRFP4 0
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
ADDRLP4 4
INDIRP4
CVPU4 4
ADDRLP4 72
INDIRU4
SUBU4
CVUI4 4
GEI4 $114
ADDRLP4 68
ADDRLP4 20
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
ASGNI4
ADDRGP4 $115
JUMPV
LABELV $114
ADDRLP4 68
ADDRLP4 4
INDIRP4
CVPU4 4
ADDRLP4 20
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
ASGNI4
LABELV $115
ADDRLP4 12
ADDRLP4 68
INDIRI4
ASGNI4
line 172
;172:	vecswap(a, pb - r, r);
ADDRLP4 12
INDIRI4
CNSTI4 0
LEI4 $116
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
INDIRP4
ADDRLP4 12
INDIRI4
SUBP4
ARGP4
ADDRLP4 12
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 swapfunc
CALLV
pop
LABELV $116
line 173
;173:	r = min(pd - pc, pn - pd - es);
ADDRLP4 84
ADDRLP4 24
INDIRP4
CVPU4 4
ASGNU4
ADDRLP4 84
INDIRU4
ADDRLP4 8
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
ADDRLP4 36
INDIRP4
CVPU4 4
ADDRLP4 84
INDIRU4
SUBU4
CVUI4 4
ADDRFP4 8
INDIRI4
SUBI4
GEI4 $119
ADDRLP4 80
ADDRLP4 24
INDIRP4
CVPU4 4
ADDRLP4 8
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
ASGNI4
ADDRGP4 $120
JUMPV
LABELV $119
ADDRLP4 80
ADDRLP4 36
INDIRP4
CVPU4 4
ADDRLP4 24
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
ADDRFP4 8
INDIRI4
SUBI4
ASGNI4
LABELV $120
ADDRLP4 12
ADDRLP4 80
INDIRI4
ASGNI4
line 174
;174:	vecswap(pb, pn - r, r);
ADDRLP4 12
INDIRI4
CNSTI4 0
LEI4 $121
ADDRLP4 4
INDIRP4
ARGP4
ADDRLP4 36
INDIRP4
ADDRLP4 12
INDIRI4
SUBP4
ARGP4
ADDRLP4 12
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 swapfunc
CALLV
pop
LABELV $121
line 175
;175:	if ((r = pb - pa) > es)
ADDRLP4 92
ADDRLP4 4
INDIRP4
CVPU4 4
ADDRLP4 20
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
ASGNI4
ADDRLP4 12
ADDRLP4 92
INDIRI4
ASGNI4
ADDRLP4 92
INDIRI4
ADDRFP4 8
INDIRI4
LEI4 $123
line 176
;176:		qsort(a, r / es, es, cmp);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 96
ADDRFP4 8
INDIRI4
ASGNI4
ADDRLP4 12
INDIRI4
ADDRLP4 96
INDIRI4
DIVI4
ARGI4
ADDRLP4 96
INDIRI4
ARGI4
ADDRFP4 12
INDIRP4
ARGP4
ADDRGP4 qsort
CALLV
pop
LABELV $123
line 177
;177:	if ((r = pd - pc) > es) {
ADDRLP4 100
ADDRLP4 24
INDIRP4
CVPU4 4
ADDRLP4 8
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
ASGNI4
ADDRLP4 12
ADDRLP4 100
INDIRI4
ASGNI4
ADDRLP4 100
INDIRI4
ADDRFP4 8
INDIRI4
LEI4 $125
line 179
;178:		/* Iterate rather than recurse to save stack space */
;179:		a = pn - r;
ADDRFP4 0
ADDRLP4 36
INDIRP4
ADDRLP4 12
INDIRI4
SUBP4
ASGNP4
line 180
;180:		n = r / es;
ADDRFP4 4
ADDRLP4 12
INDIRI4
ADDRFP4 8
INDIRI4
DIVI4
ASGNI4
line 181
;181:		goto loop;
ADDRGP4 $49
JUMPV
LABELV $125
line 184
;182:	}
;183:	/*		qsort(pn - r, r / es, es, cmp);*/
;184:}
LABELV $48
endproc qsort 104 16
export strlen
proc strlen 4 0
line 188
;185:
;186://==================================================================================
;187:
;188:size_t strlen(const char *string) {
line 191
;189:	const char *s;
;190:
;191:	s = string;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $129
JUMPV
LABELV $128
line 192
;192:	while (*s) {
line 193
;193:		s++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 194
;194:	}
LABELV $129
line 192
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $128
line 195
;195:	return s - string;
ADDRLP4 0
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
RETI4
LABELV $127
endproc strlen 4 0
export strcat
proc strcat 16 0
line 198
;196:}
;197:
;198:char *strcat(char *strDestination, const char *strSource) {
line 201
;199:	char *s;
;200:
;201:	s = strDestination;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $133
JUMPV
LABELV $132
line 202
;202:	while (*s) {
line 203
;203:		s++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 204
;204:	}
LABELV $133
line 202
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $132
ADDRGP4 $136
JUMPV
LABELV $135
line 205
;205:	while (*strSource) {
line 206
;206:		*s++ = *strSource++;
ADDRLP4 4
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 12
CNSTI4 1
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ADDRLP4 12
INDIRI4
ADDP4
ASGNP4
ADDRLP4 8
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 4
ADDRLP4 8
INDIRP4
ADDRLP4 12
INDIRI4
ADDP4
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 8
INDIRP4
INDIRI1
ASGNI1
line 207
;207:	}
LABELV $136
line 205
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $135
line 208
;208:	*s = 0;
ADDRLP4 0
INDIRP4
CNSTI1 0
ASGNI1
line 209
;209:	return strDestination;
ADDRFP4 0
INDIRP4
RETP4
LABELV $131
endproc strcat 16 0
export strcpy
proc strcpy 16 0
line 212
;210:}
;211:
;212:char *strcpy(char *strDestination, const char *strSource) {
line 215
;213:	char *s;
;214:
;215:	s = strDestination;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $140
JUMPV
LABELV $139
line 216
;216:	while (*strSource) {
line 217
;217:		*s++ = *strSource++;
ADDRLP4 4
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 12
CNSTI4 1
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ADDRLP4 12
INDIRI4
ADDP4
ASGNP4
ADDRLP4 8
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 4
ADDRLP4 8
INDIRP4
ADDRLP4 12
INDIRI4
ADDP4
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 8
INDIRP4
INDIRI1
ASGNI1
line 218
;218:	}
LABELV $140
line 216
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $139
line 219
;219:	*s = 0;
ADDRLP4 0
INDIRP4
CNSTI1 0
ASGNI1
line 220
;220:	return strDestination;
ADDRFP4 0
INDIRP4
RETP4
LABELV $138
endproc strcpy 16 0
export strcmp
proc strcmp 12 0
line 223
;221:}
;222:
;223:int strcmp(const char *string1, const char *string2) {
ADDRGP4 $144
JUMPV
LABELV $143
line 224
;224:	while (*string1 == *string2 && *string1 && *string2) {
line 225
;225:		string1++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 226
;226:		string2++;
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 227
;227:	}
LABELV $144
line 224
ADDRLP4 0
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 4
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
INDIRI4
ADDRLP4 4
INDIRI4
NEI4 $147
ADDRLP4 8
CNSTI4 0
ASGNI4
ADDRLP4 0
INDIRI4
ADDRLP4 8
INDIRI4
EQI4 $147
ADDRLP4 4
INDIRI4
ADDRLP4 8
INDIRI4
NEI4 $143
LABELV $147
line 228
;228:	return *string1 - *string2;
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
SUBI4
RETI4
LABELV $142
endproc strcmp 12 0
export strchr
proc strchr 0 0
line 231
;229:}
;230:
;231:char *strchr(const char *string, int c) {
ADDRGP4 $150
JUMPV
LABELV $149
line 232
;232:	while (*string) {
line 233
;233:		if (*string == c) {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ADDRFP4 4
INDIRI4
NEI4 $152
line 234
;234:			return (char *) string;
ADDRFP4 0
INDIRP4
RETP4
ADDRGP4 $148
JUMPV
LABELV $152
line 236
;235:		}
;236:		string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 237
;237:	}
LABELV $150
line 232
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $149
line 238
;238:	if (c)
ADDRFP4 4
INDIRI4
CNSTI4 0
EQI4 $154
line 239
;239:		return NULL;
CNSTP4 0
RETP4
ADDRGP4 $148
JUMPV
LABELV $154
line 241
;240:	else
;241:		return (char*) string;
ADDRFP4 0
INDIRP4
RETP4
LABELV $148
endproc strchr 0 0
export strrchr
proc strrchr 4 0
line 244
;242:}
;243:
;244:char *strrchr(const char *string, int c) {
line 245
;245:	const char *found = NULL;
ADDRLP4 0
CNSTP4 0
ASGNP4
ADDRGP4 $158
JUMPV
LABELV $157
line 247
;246:
;247:	while (*string) {
line 248
;248:		if (*string == c)
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ADDRFP4 4
INDIRI4
NEI4 $160
line 249
;249:			found = string;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $160
line 251
;250:
;251:		string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 252
;252:	}
LABELV $158
line 247
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $157
line 254
;253:
;254:	if (c)
ADDRFP4 4
INDIRI4
CNSTI4 0
EQI4 $162
line 255
;255:		return (char *) found;
ADDRLP4 0
INDIRP4
RETP4
ADDRGP4 $156
JUMPV
LABELV $162
line 257
;256:	else
;257:		return (char *) string;
ADDRFP4 0
INDIRP4
RETP4
LABELV $156
endproc strrchr 4 0
export strstr
proc strstr 8 0
line 260
;258:}
;259:
;260:char *strstr(const char *string, const char *strCharSet) {
ADDRGP4 $166
JUMPV
LABELV $165
line 261
;261:	while (*string) {
line 264
;262:		int i;
;263:
;264:		for (i = 0; strCharSet[i]; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $171
JUMPV
LABELV $168
line 265
;265:			if (string[i] != strCharSet[i]) {
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
EQI4 $172
line 266
;266:				break;
ADDRGP4 $170
JUMPV
LABELV $172
line 268
;267:			}
;268:		}
LABELV $169
line 264
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $171
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $168
LABELV $170
line 269
;269:		if (!strCharSet[i]) {
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $174
line 270
;270:			return (char *) string;
ADDRFP4 0
INDIRP4
RETP4
ADDRGP4 $164
JUMPV
LABELV $174
line 272
;271:		}
;272:		string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 273
;273:	}
LABELV $166
line 261
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $165
line 274
;274:	return (char *) 0;
CNSTP4 0
RETP4
LABELV $164
endproc strstr 8 0
export tolower
proc tolower 4 0
line 277
;275:}
;276:
;277:int tolower(int c) {
line 278
;278:	if (c >= 'A' && c <= 'Z') {
ADDRLP4 0
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 65
LTI4 $177
ADDRLP4 0
INDIRI4
CNSTI4 90
GTI4 $177
line 279
;279:		c += 'a' - 'A';
ADDRFP4 0
ADDRFP4 0
INDIRI4
CNSTI4 32
ADDI4
ASGNI4
line 280
;280:	}
LABELV $177
line 281
;281:	return c;
ADDRFP4 0
INDIRI4
RETI4
LABELV $176
endproc tolower 4 0
export toupper
proc toupper 4 0
line 284
;282:}
;283:
;284:int toupper(int c) {
line 285
;285:	if (c >= 'a' && c <= 'z') {
ADDRLP4 0
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 97
LTI4 $180
ADDRLP4 0
INDIRI4
CNSTI4 122
GTI4 $180
line 286
;286:		c += 'A' - 'a';
ADDRFP4 0
ADDRFP4 0
INDIRI4
CNSTI4 -32
ADDI4
ASGNI4
line 287
;287:	}
LABELV $180
line 288
;288:	return c;
ADDRFP4 0
INDIRI4
RETI4
LABELV $179
endproc toupper 4 0
export memmove
proc memmove 8 0
line 291
;289:}
;290:
;291:void *memmove(void *dest, const void *src, size_t count) {
line 294
;292:	int i;
;293:
;294:	if (dest > src) {
ADDRFP4 0
INDIRP4
CVPU4 4
ADDRFP4 4
INDIRP4
CVPU4 4
LEU4 $183
line 295
;295:		for (i = count - 1; i >= 0; i--) {
ADDRLP4 0
ADDRFP4 8
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRGP4 $188
JUMPV
LABELV $185
line 296
;296:			((char *) dest)[i] = ((char *) src)[i];
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
ASGNI1
line 297
;297:		}
LABELV $186
line 295
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
LABELV $188
ADDRLP4 0
INDIRI4
CNSTI4 0
GEI4 $185
line 298
;298:	} else {
ADDRGP4 $184
JUMPV
LABELV $183
line 299
;299:		for (i = 0; i < count; i++) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $192
JUMPV
LABELV $189
line 300
;300:			((char *) dest)[i] = ((char *) src)[i];
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
ASGNI1
line 301
;301:		}
LABELV $190
line 299
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $192
ADDRLP4 0
INDIRI4
ADDRFP4 8
INDIRI4
LTI4 $189
line 302
;302:	}
LABELV $184
line 303
;303:	return dest;
ADDRFP4 0
INDIRP4
RETP4
LABELV $182
endproc memmove 8 0
proc powN 8 8
line 764
;304:}
;305:
;306:
;307:#if 0
;308:
;309:double floor(double x) {
;310:	return (int) (x + 0x40000000) - 0x40000000;
;311:}
;312:
;313:void *memset(void *dest, int c, size_t count) {
;314:	while (count--) {
;315:		((char *) dest)[count] = c;
;316:	}
;317:	return dest;
;318:}
;319:
;320:void *memcpy(void *dest, const void *src, size_t count) {
;321:	while (count--) {
;322:		((char *) dest)[count] = ((char *) src)[count];
;323:	}
;324:	return dest;
;325:}
;326:
;327:char *strncpy(char *strDest, const char *strSource, size_t count) {
;328:	char *s;
;329:
;330:	s = strDest;
;331:	while (*strSource && count) {
;332:		*s++ = *strSource++;
;333:		count--;
;334:	}
;335:	while (count--) {
;336:		*s++ = 0;
;337:	}
;338:	return strDest;
;339:}
;340:
;341:double sqrt(double x) {
;342:	float y;
;343:	float delta;
;344:	float maxError;
;345:
;346:	if (x <= 0) {
;347:		return 0;
;348:	}
;349:
;350:	// initial guess
;351:	y = x / 2;
;352:
;353:	// refine
;354:	maxError = x * 0.001;
;355:
;356:	do {
;357:		delta = (y * y) - x;
;358:		y -= delta / (2 * y);
;359:	} while (delta > maxError || delta < -maxError);
;360:
;361:	return y;
;362:}
;363:
;364:
;365:float sintable[1024] = {
;366:	0.000000, 0.001534, 0.003068, 0.004602, 0.006136, 0.007670, 0.009204, 0.010738,
;367:	0.012272, 0.013805, 0.015339, 0.016873, 0.018407, 0.019940, 0.021474, 0.023008,
;368:	0.024541, 0.026075, 0.027608, 0.029142, 0.030675, 0.032208, 0.033741, 0.035274,
;369:	0.036807, 0.038340, 0.039873, 0.041406, 0.042938, 0.044471, 0.046003, 0.047535,
;370:	0.049068, 0.050600, 0.052132, 0.053664, 0.055195, 0.056727, 0.058258, 0.059790,
;371:	0.061321, 0.062852, 0.064383, 0.065913, 0.067444, 0.068974, 0.070505, 0.072035,
;372:	0.073565, 0.075094, 0.076624, 0.078153, 0.079682, 0.081211, 0.082740, 0.084269,
;373:	0.085797, 0.087326, 0.088854, 0.090381, 0.091909, 0.093436, 0.094963, 0.096490,
;374:	0.098017, 0.099544, 0.101070, 0.102596, 0.104122, 0.105647, 0.107172, 0.108697,
;375:	0.110222, 0.111747, 0.113271, 0.114795, 0.116319, 0.117842, 0.119365, 0.120888,
;376:	0.122411, 0.123933, 0.125455, 0.126977, 0.128498, 0.130019, 0.131540, 0.133061,
;377:	0.134581, 0.136101, 0.137620, 0.139139, 0.140658, 0.142177, 0.143695, 0.145213,
;378:	0.146730, 0.148248, 0.149765, 0.151281, 0.152797, 0.154313, 0.155828, 0.157343,
;379:	0.158858, 0.160372, 0.161886, 0.163400, 0.164913, 0.166426, 0.167938, 0.169450,
;380:	0.170962, 0.172473, 0.173984, 0.175494, 0.177004, 0.178514, 0.180023, 0.181532,
;381:	0.183040, 0.184548, 0.186055, 0.187562, 0.189069, 0.190575, 0.192080, 0.193586,
;382:	0.195090, 0.196595, 0.198098, 0.199602, 0.201105, 0.202607, 0.204109, 0.205610,
;383:	0.207111, 0.208612, 0.210112, 0.211611, 0.213110, 0.214609, 0.216107, 0.217604,
;384:	0.219101, 0.220598, 0.222094, 0.223589, 0.225084, 0.226578, 0.228072, 0.229565,
;385:	0.231058, 0.232550, 0.234042, 0.235533, 0.237024, 0.238514, 0.240003, 0.241492,
;386:	0.242980, 0.244468, 0.245955, 0.247442, 0.248928, 0.250413, 0.251898, 0.253382,
;387:	0.254866, 0.256349, 0.257831, 0.259313, 0.260794, 0.262275, 0.263755, 0.265234,
;388:	0.266713, 0.268191, 0.269668, 0.271145, 0.272621, 0.274097, 0.275572, 0.277046,
;389:	0.278520, 0.279993, 0.281465, 0.282937, 0.284408, 0.285878, 0.287347, 0.288816,
;390:	0.290285, 0.291752, 0.293219, 0.294685, 0.296151, 0.297616, 0.299080, 0.300543,
;391:	0.302006, 0.303468, 0.304929, 0.306390, 0.307850, 0.309309, 0.310767, 0.312225,
;392:	0.313682, 0.315138, 0.316593, 0.318048, 0.319502, 0.320955, 0.322408, 0.323859,
;393:	0.325310, 0.326760, 0.328210, 0.329658, 0.331106, 0.332553, 0.334000, 0.335445,
;394:	0.336890, 0.338334, 0.339777, 0.341219, 0.342661, 0.344101, 0.345541, 0.346980,
;395:	0.348419, 0.349856, 0.351293, 0.352729, 0.354164, 0.355598, 0.357031, 0.358463,
;396:	0.359895, 0.361326, 0.362756, 0.364185, 0.365613, 0.367040, 0.368467, 0.369892,
;397:	0.371317, 0.372741, 0.374164, 0.375586, 0.377007, 0.378428, 0.379847, 0.381266,
;398:	0.382683, 0.384100, 0.385516, 0.386931, 0.388345, 0.389758, 0.391170, 0.392582,
;399:	0.393992, 0.395401, 0.396810, 0.398218, 0.399624, 0.401030, 0.402435, 0.403838,
;400:	0.405241, 0.406643, 0.408044, 0.409444, 0.410843, 0.412241, 0.413638, 0.415034,
;401:	0.416430, 0.417824, 0.419217, 0.420609, 0.422000, 0.423390, 0.424780, 0.426168,
;402:	0.427555, 0.428941, 0.430326, 0.431711, 0.433094, 0.434476, 0.435857, 0.437237,
;403:	0.438616, 0.439994, 0.441371, 0.442747, 0.444122, 0.445496, 0.446869, 0.448241,
;404:	0.449611, 0.450981, 0.452350, 0.453717, 0.455084, 0.456449, 0.457813, 0.459177,
;405:	0.460539, 0.461900, 0.463260, 0.464619, 0.465976, 0.467333, 0.468689, 0.470043,
;406:	0.471397, 0.472749, 0.474100, 0.475450, 0.476799, 0.478147, 0.479494, 0.480839,
;407:	0.482184, 0.483527, 0.484869, 0.486210, 0.487550, 0.488889, 0.490226, 0.491563,
;408:	0.492898, 0.494232, 0.495565, 0.496897, 0.498228, 0.499557, 0.500885, 0.502212,
;409:	0.503538, 0.504863, 0.506187, 0.507509, 0.508830, 0.510150, 0.511469, 0.512786,
;410:	0.514103, 0.515418, 0.516732, 0.518045, 0.519356, 0.520666, 0.521975, 0.523283,
;411:	0.524590, 0.525895, 0.527199, 0.528502, 0.529804, 0.531104, 0.532403, 0.533701,
;412:	0.534998, 0.536293, 0.537587, 0.538880, 0.540171, 0.541462, 0.542751, 0.544039,
;413:	0.545325, 0.546610, 0.547894, 0.549177, 0.550458, 0.551738, 0.553017, 0.554294,
;414:	0.555570, 0.556845, 0.558119, 0.559391, 0.560662, 0.561931, 0.563199, 0.564466,
;415:	0.565732, 0.566996, 0.568259, 0.569521, 0.570781, 0.572040, 0.573297, 0.574553,
;416:	0.575808, 0.577062, 0.578314, 0.579565, 0.580814, 0.582062, 0.583309, 0.584554,
;417:	0.585798, 0.587040, 0.588282, 0.589521, 0.590760, 0.591997, 0.593232, 0.594466,
;418:	0.595699, 0.596931, 0.598161, 0.599389, 0.600616, 0.601842, 0.603067, 0.604290,
;419:	0.605511, 0.606731, 0.607950, 0.609167, 0.610383, 0.611597, 0.612810, 0.614022,
;420:	0.615232, 0.616440, 0.617647, 0.618853, 0.620057, 0.621260, 0.622461, 0.623661,
;421:	0.624859, 0.626056, 0.627252, 0.628446, 0.629638, 0.630829, 0.632019, 0.633207,
;422:	0.634393, 0.635578, 0.636762, 0.637944, 0.639124, 0.640303, 0.641481, 0.642657,
;423:	0.643832, 0.645005, 0.646176, 0.647346, 0.648514, 0.649681, 0.650847, 0.652011,
;424:	0.653173, 0.654334, 0.655493, 0.656651, 0.657807, 0.658961, 0.660114, 0.661266,
;425:	0.662416, 0.663564, 0.664711, 0.665856, 0.667000, 0.668142, 0.669283, 0.670422,
;426:	0.671559, 0.672695, 0.673829, 0.674962, 0.676093, 0.677222, 0.678350, 0.679476,
;427:	0.680601, 0.681724, 0.682846, 0.683965, 0.685084, 0.686200, 0.687315, 0.688429,
;428:	0.689541, 0.690651, 0.691759, 0.692866, 0.693971, 0.695075, 0.696177, 0.697278,
;429:	0.698376, 0.699473, 0.700569, 0.701663, 0.702755, 0.703845, 0.704934, 0.706021,
;430:	0.707107, 0.708191, 0.709273, 0.710353, 0.711432, 0.712509, 0.713585, 0.714659,
;431:	0.715731, 0.716801, 0.717870, 0.718937, 0.720003, 0.721066, 0.722128, 0.723188,
;432:	0.724247, 0.725304, 0.726359, 0.727413, 0.728464, 0.729514, 0.730563, 0.731609,
;433:	0.732654, 0.733697, 0.734739, 0.735779, 0.736817, 0.737853, 0.738887, 0.739920,
;434:	0.740951, 0.741980, 0.743008, 0.744034, 0.745058, 0.746080, 0.747101, 0.748119,
;435:	0.749136, 0.750152, 0.751165, 0.752177, 0.753187, 0.754195, 0.755201, 0.756206,
;436:	0.757209, 0.758210, 0.759209, 0.760207, 0.761202, 0.762196, 0.763188, 0.764179,
;437:	0.765167, 0.766154, 0.767139, 0.768122, 0.769103, 0.770083, 0.771061, 0.772036,
;438:	0.773010, 0.773983, 0.774953, 0.775922, 0.776888, 0.777853, 0.778817, 0.779778,
;439:	0.780737, 0.781695, 0.782651, 0.783605, 0.784557, 0.785507, 0.786455, 0.787402,
;440:	0.788346, 0.789289, 0.790230, 0.791169, 0.792107, 0.793042, 0.793975, 0.794907,
;441:	0.795837, 0.796765, 0.797691, 0.798615, 0.799537, 0.800458, 0.801376, 0.802293,
;442:	0.803208, 0.804120, 0.805031, 0.805940, 0.806848, 0.807753, 0.808656, 0.809558,
;443:	0.810457, 0.811355, 0.812251, 0.813144, 0.814036, 0.814926, 0.815814, 0.816701,
;444:	0.817585, 0.818467, 0.819348, 0.820226, 0.821103, 0.821977, 0.822850, 0.823721,
;445:	0.824589, 0.825456, 0.826321, 0.827184, 0.828045, 0.828904, 0.829761, 0.830616,
;446:	0.831470, 0.832321, 0.833170, 0.834018, 0.834863, 0.835706, 0.836548, 0.837387,
;447:	0.838225, 0.839060, 0.839894, 0.840725, 0.841555, 0.842383, 0.843208, 0.844032,
;448:	0.844854, 0.845673, 0.846491, 0.847307, 0.848120, 0.848932, 0.849742, 0.850549,
;449:	0.851355, 0.852159, 0.852961, 0.853760, 0.854558, 0.855354, 0.856147, 0.856939,
;450:	0.857729, 0.858516, 0.859302, 0.860085, 0.860867, 0.861646, 0.862424, 0.863199,
;451:	0.863973, 0.864744, 0.865514, 0.866281, 0.867046, 0.867809, 0.868571, 0.869330,
;452:	0.870087, 0.870842, 0.871595, 0.872346, 0.873095, 0.873842, 0.874587, 0.875329,
;453:	0.876070, 0.876809, 0.877545, 0.878280, 0.879012, 0.879743, 0.880471, 0.881197,
;454:	0.881921, 0.882643, 0.883363, 0.884081, 0.884797, 0.885511, 0.886223, 0.886932,
;455:	0.887640, 0.888345, 0.889048, 0.889750, 0.890449, 0.891146, 0.891841, 0.892534,
;456:	0.893224, 0.893913, 0.894599, 0.895284, 0.895966, 0.896646, 0.897325, 0.898001,
;457:	0.898674, 0.899346, 0.900016, 0.900683, 0.901349, 0.902012, 0.902673, 0.903332,
;458:	0.903989, 0.904644, 0.905297, 0.905947, 0.906596, 0.907242, 0.907886, 0.908528,
;459:	0.909168, 0.909806, 0.910441, 0.911075, 0.911706, 0.912335, 0.912962, 0.913587,
;460:	0.914210, 0.914830, 0.915449, 0.916065, 0.916679, 0.917291, 0.917901, 0.918508,
;461:	0.919114, 0.919717, 0.920318, 0.920917, 0.921514, 0.922109, 0.922701, 0.923291,
;462:	0.923880, 0.924465, 0.925049, 0.925631, 0.926210, 0.926787, 0.927363, 0.927935,
;463:	0.928506, 0.929075, 0.929641, 0.930205, 0.930767, 0.931327, 0.931884, 0.932440,
;464:	0.932993, 0.933544, 0.934093, 0.934639, 0.935184, 0.935726, 0.936266, 0.936803,
;465:	0.937339, 0.937872, 0.938404, 0.938932, 0.939459, 0.939984, 0.940506, 0.941026,
;466:	0.941544, 0.942060, 0.942573, 0.943084, 0.943593, 0.944100, 0.944605, 0.945107,
;467:	0.945607, 0.946105, 0.946601, 0.947094, 0.947586, 0.948075, 0.948561, 0.949046,
;468:	0.949528, 0.950008, 0.950486, 0.950962, 0.951435, 0.951906, 0.952375, 0.952842,
;469:	0.953306, 0.953768, 0.954228, 0.954686, 0.955141, 0.955594, 0.956045, 0.956494,
;470:	0.956940, 0.957385, 0.957826, 0.958266, 0.958703, 0.959139, 0.959572, 0.960002,
;471:	0.960431, 0.960857, 0.961280, 0.961702, 0.962121, 0.962538, 0.962953, 0.963366,
;472:	0.963776, 0.964184, 0.964590, 0.964993, 0.965394, 0.965793, 0.966190, 0.966584,
;473:	0.966976, 0.967366, 0.967754, 0.968139, 0.968522, 0.968903, 0.969281, 0.969657,
;474:	0.970031, 0.970403, 0.970772, 0.971139, 0.971504, 0.971866, 0.972226, 0.972584,
;475:	0.972940, 0.973293, 0.973644, 0.973993, 0.974339, 0.974684, 0.975025, 0.975365,
;476:	0.975702, 0.976037, 0.976370, 0.976700, 0.977028, 0.977354, 0.977677, 0.977999,
;477:	0.978317, 0.978634, 0.978948, 0.979260, 0.979570, 0.979877, 0.980182, 0.980485,
;478:	0.980785, 0.981083, 0.981379, 0.981673, 0.981964, 0.982253, 0.982539, 0.982824,
;479:	0.983105, 0.983385, 0.983662, 0.983937, 0.984210, 0.984480, 0.984749, 0.985014,
;480:	0.985278, 0.985539, 0.985798, 0.986054, 0.986308, 0.986560, 0.986809, 0.987057,
;481:	0.987301, 0.987544, 0.987784, 0.988022, 0.988258, 0.988491, 0.988722, 0.988950,
;482:	0.989177, 0.989400, 0.989622, 0.989841, 0.990058, 0.990273, 0.990485, 0.990695,
;483:	0.990903, 0.991108, 0.991311, 0.991511, 0.991710, 0.991906, 0.992099, 0.992291,
;484:	0.992480, 0.992666, 0.992850, 0.993032, 0.993212, 0.993389, 0.993564, 0.993737,
;485:	0.993907, 0.994075, 0.994240, 0.994404, 0.994565, 0.994723, 0.994879, 0.995033,
;486:	0.995185, 0.995334, 0.995481, 0.995625, 0.995767, 0.995907, 0.996045, 0.996180,
;487:	0.996313, 0.996443, 0.996571, 0.996697, 0.996820, 0.996941, 0.997060, 0.997176,
;488:	0.997290, 0.997402, 0.997511, 0.997618, 0.997723, 0.997825, 0.997925, 0.998023,
;489:	0.998118, 0.998211, 0.998302, 0.998390, 0.998476, 0.998559, 0.998640, 0.998719,
;490:	0.998795, 0.998870, 0.998941, 0.999011, 0.999078, 0.999142, 0.999205, 0.999265,
;491:	0.999322, 0.999378, 0.999431, 0.999481, 0.999529, 0.999575, 0.999619, 0.999660,
;492:	0.999699, 0.999735, 0.999769, 0.999801, 0.999831, 0.999858, 0.999882, 0.999905,
;493:	0.999925, 0.999942, 0.999958, 0.999971, 0.999981, 0.999989, 0.999995, 0.999999
;494:};
;495:
;496:double sin(double x) {
;497:	int index;
;498:	int quad;
;499:
;500:	index = 1024 * x / (M_PI * 0.5);
;501:	quad = (index >> 10) & 3;
;502:	index &= 1023;
;503:	switch (quad) {
;504:		case 0:
;505:			return sintable[index];
;506:		case 1:
;507:			return sintable[1023 - index];
;508:		case 2:
;509:			return -sintable[index];
;510:		case 3:
;511:			return -sintable[1023 - index];
;512:	}
;513:	return 0;
;514:}
;515:
;516:double cos(double x) {
;517:	int index;
;518:	int quad;
;519:
;520:	index = 1024 * x / (M_PI * 0.5);
;521:	quad = (index >> 10) & 3;
;522:	index &= 1023;
;523:	switch (quad) {
;524:		case 3:
;525:			return sintable[index];
;526:		case 0:
;527:			return sintable[1023 - index];
;528:		case 1:
;529:			return -sintable[index];
;530:		case 2:
;531:			return -sintable[1023 - index];
;532:	}
;533:	return 0;
;534:}
;535:
;536:
;537:/*
;538:void create_acostable( void ) {
;539:	int i;
;540:	FILE *fp;
;541:	float a;
;542:
;543:	fp = fopen("c:\\acostable.txt", "w");
;544:	fprintf(fp, "float acostable[] = {");
;545:	for (i = 0; i < 1024; i++) {
;546:		if (!(i & 7))
;547:			fprintf(fp, "\n");
;548:		a = acos( (float) -1 + i / 512 );
;549:		fprintf(fp, "%1.8f,", a);
;550:	}
;551:	fprintf(fp, "\n}\n");
;552:	fclose(fp);
;553:}
;554: */
;555:
;556:float acostable[] = {
;557:	3.14159265, 3.07908248, 3.05317551, 3.03328655, 3.01651113, 3.00172442, 2.98834964, 2.97604422,
;558:	2.96458497, 2.95381690, 2.94362719, 2.93393068, 2.92466119, 2.91576615, 2.90720289, 2.89893629,
;559:	2.89093699, 2.88318015, 2.87564455, 2.86831188, 2.86116621, 2.85419358, 2.84738169, 2.84071962,
;560:	2.83419760, 2.82780691, 2.82153967, 2.81538876, 2.80934770, 2.80341062, 2.79757211, 2.79182724,
;561:	2.78617145, 2.78060056, 2.77511069, 2.76969824, 2.76435988, 2.75909250, 2.75389319, 2.74875926,
;562:	2.74368816, 2.73867752, 2.73372510, 2.72882880, 2.72398665, 2.71919677, 2.71445741, 2.70976688,
;563:	2.70512362, 2.70052613, 2.69597298, 2.69146283, 2.68699438, 2.68256642, 2.67817778, 2.67382735,
;564:	2.66951407, 2.66523692, 2.66099493, 2.65678719, 2.65261279, 2.64847088, 2.64436066, 2.64028133,
;565:	2.63623214, 2.63221238, 2.62822133, 2.62425835, 2.62032277, 2.61641398, 2.61253138, 2.60867440,
;566:	2.60484248, 2.60103507, 2.59725167, 2.59349176, 2.58975488, 2.58604053, 2.58234828, 2.57867769,
;567:	2.57502832, 2.57139977, 2.56779164, 2.56420354, 2.56063509, 2.55708594, 2.55355572, 2.55004409,
;568:	2.54655073, 2.54307530, 2.53961750, 2.53617701, 2.53275354, 2.52934680, 2.52595650, 2.52258238,
;569:	2.51922417, 2.51588159, 2.51255441, 2.50924238, 2.50594525, 2.50266278, 2.49939476, 2.49614096,
;570:	2.49290115, 2.48967513, 2.48646269, 2.48326362, 2.48007773, 2.47690482, 2.47374472, 2.47059722,
;571:	2.46746215, 2.46433933, 2.46122860, 2.45812977, 2.45504269, 2.45196720, 2.44890314, 2.44585034,
;572:	2.44280867, 2.43977797, 2.43675809, 2.43374890, 2.43075025, 2.42776201, 2.42478404, 2.42181622,
;573:	2.41885841, 2.41591048, 2.41297232, 2.41004380, 2.40712480, 2.40421521, 2.40131491, 2.39842379,
;574:	2.39554173, 2.39266863, 2.38980439, 2.38694889, 2.38410204, 2.38126374, 2.37843388, 2.37561237,
;575:	2.37279910, 2.36999400, 2.36719697, 2.36440790, 2.36162673, 2.35885335, 2.35608768, 2.35332964,
;576:	2.35057914, 2.34783610, 2.34510044, 2.34237208, 2.33965094, 2.33693695, 2.33423003, 2.33153010,
;577:	2.32883709, 2.32615093, 2.32347155, 2.32079888, 2.31813284, 2.31547337, 2.31282041, 2.31017388,
;578:	2.30753373, 2.30489988, 2.30227228, 2.29965086, 2.29703556, 2.29442632, 2.29182309, 2.28922580,
;579:	2.28663439, 2.28404881, 2.28146900, 2.27889490, 2.27632647, 2.27376364, 2.27120637, 2.26865460,
;580:	2.26610827, 2.26356735, 2.26103177, 2.25850149, 2.25597646, 2.25345663, 2.25094195, 2.24843238,
;581:	2.24592786, 2.24342836, 2.24093382, 2.23844420, 2.23595946, 2.23347956, 2.23100444, 2.22853408,
;582:	2.22606842, 2.22360742, 2.22115104, 2.21869925, 2.21625199, 2.21380924, 2.21137096, 2.20893709,
;583:	2.20650761, 2.20408248, 2.20166166, 2.19924511, 2.19683280, 2.19442469, 2.19202074, 2.18962092,
;584:	2.18722520, 2.18483354, 2.18244590, 2.18006225, 2.17768257, 2.17530680, 2.17293493, 2.17056692,
;585:	2.16820274, 2.16584236, 2.16348574, 2.16113285, 2.15878367, 2.15643816, 2.15409630, 2.15175805,
;586:	2.14942338, 2.14709226, 2.14476468, 2.14244059, 2.14011997, 2.13780279, 2.13548903, 2.13317865,
;587:	2.13087163, 2.12856795, 2.12626757, 2.12397047, 2.12167662, 2.11938600, 2.11709859, 2.11481435,
;588:	2.11253326, 2.11025530, 2.10798044, 2.10570867, 2.10343994, 2.10117424, 2.09891156, 2.09665185,
;589:	2.09439510, 2.09214129, 2.08989040, 2.08764239, 2.08539725, 2.08315496, 2.08091550, 2.07867884,
;590:	2.07644495, 2.07421383, 2.07198545, 2.06975978, 2.06753681, 2.06531651, 2.06309887, 2.06088387,
;591:	2.05867147, 2.05646168, 2.05425445, 2.05204979, 2.04984765, 2.04764804, 2.04545092, 2.04325628,
;592:	2.04106409, 2.03887435, 2.03668703, 2.03450211, 2.03231957, 2.03013941, 2.02796159, 2.02578610,
;593:	2.02361292, 2.02144204, 2.01927344, 2.01710710, 2.01494300, 2.01278113, 2.01062146, 2.00846399,
;594:	2.00630870, 2.00415556, 2.00200457, 1.99985570, 1.99770895, 1.99556429, 1.99342171, 1.99128119,
;595:	1.98914271, 1.98700627, 1.98487185, 1.98273942, 1.98060898, 1.97848051, 1.97635399, 1.97422942,
;596:	1.97210676, 1.96998602, 1.96786718, 1.96575021, 1.96363511, 1.96152187, 1.95941046, 1.95730088,
;597:	1.95519310, 1.95308712, 1.95098292, 1.94888050, 1.94677982, 1.94468089, 1.94258368, 1.94048818,
;598:	1.93839439, 1.93630228, 1.93421185, 1.93212308, 1.93003595, 1.92795046, 1.92586659, 1.92378433,
;599:	1.92170367, 1.91962459, 1.91754708, 1.91547113, 1.91339673, 1.91132385, 1.90925250, 1.90718266,
;600:	1.90511432, 1.90304746, 1.90098208, 1.89891815, 1.89685568, 1.89479464, 1.89273503, 1.89067683,
;601:	1.88862003, 1.88656463, 1.88451060, 1.88245794, 1.88040664, 1.87835668, 1.87630806, 1.87426076,
;602:	1.87221477, 1.87017008, 1.86812668, 1.86608457, 1.86404371, 1.86200412, 1.85996577, 1.85792866,
;603:	1.85589277, 1.85385809, 1.85182462, 1.84979234, 1.84776125, 1.84573132, 1.84370256, 1.84167495,
;604:	1.83964848, 1.83762314, 1.83559892, 1.83357582, 1.83155381, 1.82953289, 1.82751305, 1.82549429,
;605:	1.82347658, 1.82145993, 1.81944431, 1.81742973, 1.81541617, 1.81340362, 1.81139207, 1.80938151,
;606:	1.80737194, 1.80536334, 1.80335570, 1.80134902, 1.79934328, 1.79733848, 1.79533460, 1.79333164,
;607:	1.79132959, 1.78932843, 1.78732817, 1.78532878, 1.78333027, 1.78133261, 1.77933581, 1.77733985,
;608:	1.77534473, 1.77335043, 1.77135695, 1.76936428, 1.76737240, 1.76538132, 1.76339101, 1.76140148,
;609:	1.75941271, 1.75742470, 1.75543743, 1.75345090, 1.75146510, 1.74948002, 1.74749565, 1.74551198,
;610:	1.74352900, 1.74154672, 1.73956511, 1.73758417, 1.73560389, 1.73362426, 1.73164527, 1.72966692,
;611:	1.72768920, 1.72571209, 1.72373560, 1.72175971, 1.71978441, 1.71780969, 1.71583556, 1.71386199,
;612:	1.71188899, 1.70991653, 1.70794462, 1.70597325, 1.70400241, 1.70203209, 1.70006228, 1.69809297,
;613:	1.69612416, 1.69415584, 1.69218799, 1.69022062, 1.68825372, 1.68628727, 1.68432127, 1.68235571,
;614:	1.68039058, 1.67842588, 1.67646160, 1.67449772, 1.67253424, 1.67057116, 1.66860847, 1.66664615,
;615:	1.66468420, 1.66272262, 1.66076139, 1.65880050, 1.65683996, 1.65487975, 1.65291986, 1.65096028,
;616:	1.64900102, 1.64704205, 1.64508338, 1.64312500, 1.64116689, 1.63920905, 1.63725148, 1.63529416,
;617:	1.63333709, 1.63138026, 1.62942366, 1.62746728, 1.62551112, 1.62355517, 1.62159943, 1.61964388,
;618:	1.61768851, 1.61573332, 1.61377831, 1.61182346, 1.60986877, 1.60791422, 1.60595982, 1.60400556,
;619:	1.60205142, 1.60009739, 1.59814349, 1.59618968, 1.59423597, 1.59228235, 1.59032882, 1.58837536,
;620:	1.58642196, 1.58446863, 1.58251535, 1.58056211, 1.57860891, 1.57665574, 1.57470259, 1.57274945,
;621:	1.57079633, 1.56884320, 1.56689007, 1.56493692, 1.56298375, 1.56103055, 1.55907731, 1.55712403,
;622:	1.55517069, 1.55321730, 1.55126383, 1.54931030, 1.54735668, 1.54540297, 1.54344917, 1.54149526,
;623:	1.53954124, 1.53758710, 1.53563283, 1.53367843, 1.53172389, 1.52976919, 1.52781434, 1.52585933,
;624:	1.52390414, 1.52194878, 1.51999323, 1.51803748, 1.51608153, 1.51412537, 1.51216900, 1.51021240,
;625:	1.50825556, 1.50629849, 1.50434117, 1.50238360, 1.50042576, 1.49846765, 1.49650927, 1.49455060,
;626:	1.49259163, 1.49063237, 1.48867280, 1.48671291, 1.48475270, 1.48279215, 1.48083127, 1.47887004,
;627:	1.47690845, 1.47494650, 1.47298419, 1.47102149, 1.46905841, 1.46709493, 1.46513106, 1.46316677,
;628:	1.46120207, 1.45923694, 1.45727138, 1.45530538, 1.45333893, 1.45137203, 1.44940466, 1.44743682,
;629:	1.44546850, 1.44349969, 1.44153038, 1.43956057, 1.43759024, 1.43561940, 1.43364803, 1.43167612,
;630:	1.42970367, 1.42773066, 1.42575709, 1.42378296, 1.42180825, 1.41983295, 1.41785705, 1.41588056,
;631:	1.41390346, 1.41192573, 1.40994738, 1.40796840, 1.40598877, 1.40400849, 1.40202755, 1.40004594,
;632:	1.39806365, 1.39608068, 1.39409701, 1.39211264, 1.39012756, 1.38814175, 1.38615522, 1.38416795,
;633:	1.38217994, 1.38019117, 1.37820164, 1.37621134, 1.37422025, 1.37222837, 1.37023570, 1.36824222,
;634:	1.36624792, 1.36425280, 1.36225684, 1.36026004, 1.35826239, 1.35626387, 1.35426449, 1.35226422,
;635:	1.35026307, 1.34826101, 1.34625805, 1.34425418, 1.34224937, 1.34024364, 1.33823695, 1.33622932,
;636:	1.33422072, 1.33221114, 1.33020059, 1.32818904, 1.32617649, 1.32416292, 1.32214834, 1.32013273,
;637:	1.31811607, 1.31609837, 1.31407960, 1.31205976, 1.31003885, 1.30801684, 1.30599373, 1.30396951,
;638:	1.30194417, 1.29991770, 1.29789009, 1.29586133, 1.29383141, 1.29180031, 1.28976803, 1.28773456,
;639:	1.28569989, 1.28366400, 1.28162688, 1.27958854, 1.27754894, 1.27550809, 1.27346597, 1.27142257,
;640:	1.26937788, 1.26733189, 1.26528459, 1.26323597, 1.26118602, 1.25913471, 1.25708205, 1.25502803,
;641:	1.25297262, 1.25091583, 1.24885763, 1.24679802, 1.24473698, 1.24267450, 1.24061058, 1.23854519,
;642:	1.23647833, 1.23440999, 1.23234015, 1.23026880, 1.22819593, 1.22612152, 1.22404557, 1.22196806,
;643:	1.21988898, 1.21780832, 1.21572606, 1.21364219, 1.21155670, 1.20946958, 1.20738080, 1.20529037,
;644:	1.20319826, 1.20110447, 1.19900898, 1.19691177, 1.19481283, 1.19271216, 1.19060973, 1.18850553,
;645:	1.18639955, 1.18429178, 1.18218219, 1.18007079, 1.17795754, 1.17584244, 1.17372548, 1.17160663,
;646:	1.16948589, 1.16736324, 1.16523866, 1.16311215, 1.16098368, 1.15885323, 1.15672081, 1.15458638,
;647:	1.15244994, 1.15031147, 1.14817095, 1.14602836, 1.14388370, 1.14173695, 1.13958808, 1.13743709,
;648:	1.13528396, 1.13312866, 1.13097119, 1.12881153, 1.12664966, 1.12448556, 1.12231921, 1.12015061,
;649:	1.11797973, 1.11580656, 1.11363107, 1.11145325, 1.10927308, 1.10709055, 1.10490563, 1.10271831,
;650:	1.10052856, 1.09833638, 1.09614174, 1.09394462, 1.09174500, 1.08954287, 1.08733820, 1.08513098,
;651:	1.08292118, 1.08070879, 1.07849378, 1.07627614, 1.07405585, 1.07183287, 1.06960721, 1.06737882,
;652:	1.06514770, 1.06291382, 1.06067715, 1.05843769, 1.05619540, 1.05395026, 1.05170226, 1.04945136,
;653:	1.04719755, 1.04494080, 1.04268110, 1.04041841, 1.03815271, 1.03588399, 1.03361221, 1.03133735,
;654:	1.02905939, 1.02677830, 1.02449407, 1.02220665, 1.01991603, 1.01762219, 1.01532509, 1.01302471,
;655:	1.01072102, 1.00841400, 1.00610363, 1.00378986, 1.00147268, 0.99915206, 0.99682798, 0.99450039,
;656:	0.99216928, 0.98983461, 0.98749636, 0.98515449, 0.98280898, 0.98045980, 0.97810691, 0.97575030,
;657:	0.97338991, 0.97102573, 0.96865772, 0.96628585, 0.96391009, 0.96153040, 0.95914675, 0.95675912,
;658:	0.95436745, 0.95197173, 0.94957191, 0.94716796, 0.94475985, 0.94234754, 0.93993099, 0.93751017,
;659:	0.93508504, 0.93265556, 0.93022170, 0.92778341, 0.92534066, 0.92289341, 0.92044161, 0.91798524,
;660:	0.91552424, 0.91305858, 0.91058821, 0.90811309, 0.90563319, 0.90314845, 0.90065884, 0.89816430,
;661:	0.89566479, 0.89316028, 0.89065070, 0.88813602, 0.88561619, 0.88309116, 0.88056088, 0.87802531,
;662:	0.87548438, 0.87293806, 0.87038629, 0.86782901, 0.86526619, 0.86269775, 0.86012366, 0.85754385,
;663:	0.85495827, 0.85236686, 0.84976956, 0.84716633, 0.84455709, 0.84194179, 0.83932037, 0.83669277,
;664:	0.83405893, 0.83141877, 0.82877225, 0.82611928, 0.82345981, 0.82079378, 0.81812110, 0.81544172,
;665:	0.81275556, 0.81006255, 0.80736262, 0.80465570, 0.80194171, 0.79922057, 0.79649221, 0.79375655,
;666:	0.79101352, 0.78826302, 0.78550497, 0.78273931, 0.77996593, 0.77718475, 0.77439569, 0.77159865,
;667:	0.76879355, 0.76598029, 0.76315878, 0.76032891, 0.75749061, 0.75464376, 0.75178826, 0.74892402,
;668:	0.74605092, 0.74316887, 0.74027775, 0.73737744, 0.73446785, 0.73154885, 0.72862033, 0.72568217,
;669:	0.72273425, 0.71977644, 0.71680861, 0.71383064, 0.71084240, 0.70784376, 0.70483456, 0.70181469,
;670:	0.69878398, 0.69574231, 0.69268952, 0.68962545, 0.68654996, 0.68346288, 0.68036406, 0.67725332,
;671:	0.67413051, 0.67099544, 0.66784794, 0.66468783, 0.66151492, 0.65832903, 0.65512997, 0.65191753,
;672:	0.64869151, 0.64545170, 0.64219789, 0.63892987, 0.63564741, 0.63235028, 0.62903824, 0.62571106,
;673:	0.62236849, 0.61901027, 0.61563615, 0.61224585, 0.60883911, 0.60541564, 0.60197515, 0.59851735,
;674:	0.59504192, 0.59154856, 0.58803694, 0.58450672, 0.58095756, 0.57738911, 0.57380101, 0.57019288,
;675:	0.56656433, 0.56291496, 0.55924437, 0.55555212, 0.55183778, 0.54810089, 0.54434099, 0.54055758,
;676:	0.53675018, 0.53291825, 0.52906127, 0.52517867, 0.52126988, 0.51733431, 0.51337132, 0.50938028,
;677:	0.50536051, 0.50131132, 0.49723200, 0.49312177, 0.48897987, 0.48480547, 0.48059772, 0.47635573,
;678:	0.47207859, 0.46776530, 0.46341487, 0.45902623, 0.45459827, 0.45012983, 0.44561967, 0.44106652,
;679:	0.43646903, 0.43182577, 0.42713525, 0.42239588, 0.41760600, 0.41276385, 0.40786755, 0.40291513,
;680:	0.39790449, 0.39283339, 0.38769946, 0.38250016, 0.37723277, 0.37189441, 0.36648196, 0.36099209,
;681:	0.35542120, 0.34976542, 0.34402054, 0.33818204, 0.33224495, 0.32620390, 0.32005298, 0.31378574,
;682:	0.30739505, 0.30087304, 0.29421096, 0.28739907, 0.28042645, 0.27328078, 0.26594810, 0.25841250,
;683:	0.25065566, 0.24265636, 0.23438976, 0.22582651, 0.21693146, 0.20766198, 0.19796546, 0.18777575,
;684:	0.17700769, 0.16554844, 0.15324301, 0.13986823, 0.12508152, 0.10830610, 0.08841715, 0.06251018,
;685:}
;686:
;687:double acos(double x) {
;688:	int index;
;689:
;690:	if (x < -1)
;691:		x = -1;
;692:	if (x > 1)
;693:		x = 1;
;694:	index = (float) (1.0 + x) * 511.9;
;695:	return acostable[index];
;696:}
;697:
;698:double atan2(double y, double x) {
;699:	float base;
;700:	float temp;
;701:	float dir;
;702:	float test;
;703:	int i;
;704:
;705:	if (x < 0) {
;706:		if (y >= 0) {
;707:			// quad 1
;708:			base = M_PI / 2;
;709:			temp = x;
;710:			x = y;
;711:			y = -temp;
;712:		} else {
;713:			// quad 2
;714:			base = M_PI;
;715:			x = -x;
;716:			y = -y;
;717:		}
;718:	} else {
;719:		if (y < 0) {
;720:			// quad 3
;721:			base = 3 * M_PI / 2;
;722:			temp = x;
;723:			x = -y;
;724:			y = temp;
;725:		}
;726:	}
;727:
;728:	if (y > x) {
;729:		base += M_PI / 2;
;730:		temp = x;
;731:		x = y;
;732:		y = temp;
;733:		dir = -1;
;734:	} else {
;735:		dir = 1;
;736:	}
;737:
;738:	// calcualte angle in octant 0
;739:	if (x == 0) {
;740:		return base;
;741:	}
;742:	y /= x;
;743:
;744:	for (i = 0; i < 512; i++) {
;745:		test = sintable[i] / sintable[1023 - i];
;746:		if (test > y) {
;747:			break;
;748:		}
;749:	}
;750:
;751:	return base + dir * i * (M_PI / 2048);
;752:}
;753:
;754:
;755:#endif
;756:
;757:/*
;758:===============
;759:powN
;760:
;761:Raise a double to a integer power
;762:===============
;763: */
;764:static double powN(double base, int exp) {
line 765
;765:	if (exp >= 0) {
ADDRFP4 4
INDIRI4
CNSTI4 0
LTI4 $194
line 766
;766:		double result = 1.0;
ADDRLP4 0
CNSTF4 1065353216
ASGNF4
ADDRGP4 $197
JUMPV
LABELV $196
line 772
;767:
;768:		// calculate x, x^2, x^4, ... by repeated squaring
;769:		// and multiply together the ones corresponding to the
;770:		// binary digits of the exponent
;771:		// e.g. x^73 = x^(1 + 8 + 64) = x * x^8 * x^64
;772:		while (exp > 0) {
line 773
;773:			if (exp % 2 == 1)
ADDRFP4 4
INDIRI4
CNSTI4 2
MODI4
CNSTI4 1
NEI4 $199
line 774
;774:				result *= base;
ADDRLP4 0
ADDRLP4 0
INDIRF4
ADDRFP4 0
INDIRF4
MULF4
ASGNF4
LABELV $199
line 776
;775:
;776:			base *= base;
ADDRLP4 4
ADDRFP4 0
INDIRF4
ASGNF4
ADDRFP4 0
ADDRLP4 4
INDIRF4
ADDRLP4 4
INDIRF4
MULF4
ASGNF4
line 777
;777:			exp /= 2;
ADDRFP4 4
ADDRFP4 4
INDIRI4
CNSTI4 2
DIVI4
ASGNI4
line 778
;778:		}
LABELV $197
line 772
ADDRFP4 4
INDIRI4
CNSTI4 0
GTI4 $196
line 780
;779:
;780:		return result;
ADDRLP4 0
INDIRF4
RETF4
ADDRGP4 $193
JUMPV
LABELV $194
line 783
;781:	}		// if exp is INT_MIN, the next clause will be upset,
;782:		// because -exp isn't representable
;783:	else if (exp == INT_MIN)
ADDRFP4 4
INDIRI4
CNSTI4 -2147483648
NEI4 $201
line 784
;784:		return powN(base, exp + 1) / base;
ADDRFP4 0
INDIRF4
ARGF4
ADDRFP4 4
INDIRI4
CNSTI4 1
ADDI4
ARGI4
ADDRLP4 0
ADDRGP4 powN
CALLF4
ASGNF4
ADDRLP4 0
INDIRF4
ADDRFP4 0
INDIRF4
DIVF4
RETF4
ADDRGP4 $193
JUMPV
LABELV $201
line 787
;785:		// x < 0
;786:	else
;787:		return 1.0 / powN(base, -exp);
ADDRFP4 0
INDIRF4
ARGF4
ADDRFP4 4
INDIRI4
NEGI4
ARGI4
ADDRLP4 4
ADDRGP4 powN
CALLF4
ASGNF4
CNSTF4 1065353216
ADDRLP4 4
INDIRF4
DIVF4
RETF4
LABELV $193
endproc powN 8 8
export tan
proc tan 8 4
line 790
;788:}
;789:
;790:double tan(double x) {
line 791
;791:	return sin(x) / cos(x);
ADDRFP4 0
INDIRF4
ARGF4
ADDRLP4 0
ADDRGP4 sin
CALLF4
ASGNF4
ADDRFP4 0
INDIRF4
ARGF4
ADDRLP4 4
ADDRGP4 cos
CALLF4
ASGNF4
ADDRLP4 0
INDIRF4
ADDRLP4 4
INDIRF4
DIVF4
RETF4
LABELV $203
endproc tan 8 4
data
align 4
LABELV randSeed
byte 4 0
export srand
code
proc srand 0 0
line 797
;792:}
;793:
;794:
;795:static unsigned int randSeed = 0;
;796:
;797:void srand(unsigned seed) {
line 798
;798:	randSeed = seed;
ADDRGP4 randSeed
ADDRFP4 0
INDIRU4
ASGNU4
line 799
;799:}
LABELV $204
endproc srand 0 0
export rand
proc rand 4 0
line 801
;800:
;801:int rand(void) {
line 802
;802:	randSeed = (1103515245 * randSeed + 12345) ;
ADDRLP4 0
ADDRGP4 randSeed
ASGNP4
ADDRLP4 0
INDIRP4
CNSTU4 1103515245
ADDRLP4 0
INDIRP4
INDIRU4
MULU4
CNSTU4 12345
ADDU4
ASGNU4
line 803
;803:	return (randSeed>>16) & RAND_MAX;
ADDRGP4 randSeed
INDIRU4
CNSTI4 16
RSHU4
CNSTU4 32767
BANDU4
CVUI4 4
RETI4
LABELV $205
endproc rand 4 0
export atof
proc atof 32 0
line 806
;804:}
;805:
;806:double atof(const char *string) {
ADDRGP4 $208
JUMPV
LABELV $207
line 813
;807:	float sign;
;808:	float value;
;809:	int c;
;810:
;811:
;812:	// skip whitespace
;813:	while (*string <= ' ') {
line 814
;814:		if (!*string) {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $210
line 815
;815:			return 0;
CNSTF4 0
RETF4
ADDRGP4 $206
JUMPV
LABELV $210
line 817
;816:		}
;817:		string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 818
;818:	}
LABELV $208
line 813
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 32
LEI4 $207
line 821
;819:
;820:	// check sign
;821:	switch (*string) {
ADDRLP4 12
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 43
EQI4 $215
ADDRLP4 12
INDIRI4
CNSTI4 45
EQI4 $216
ADDRGP4 $212
JUMPV
LABELV $215
line 823
;822:		case '+':
;823:			string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 824
;824:			sign = 1;
ADDRLP4 8
CNSTF4 1065353216
ASGNF4
line 825
;825:			break;
ADDRGP4 $213
JUMPV
LABELV $216
line 827
;826:		case '-':
;827:			string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 828
;828:			sign = -1;
ADDRLP4 8
CNSTF4 3212836864
ASGNF4
line 829
;829:			break;
ADDRGP4 $213
JUMPV
LABELV $212
line 831
;830:		default:
;831:			sign = 1;
ADDRLP4 8
CNSTF4 1065353216
ASGNF4
line 832
;832:			break;
LABELV $213
line 836
;833:	}
;834:
;835:	// read digits
;836:	value = 0;
ADDRLP4 4
CNSTF4 0
ASGNF4
line 837
;837:	c = string[0];
ADDRLP4 0
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 838
;838:	if (c != '.') {
ADDRLP4 0
INDIRI4
CNSTI4 46
EQI4 $217
LABELV $219
line 839
;839:		do {
line 840
;840:			c = *string++;
ADDRLP4 20
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 20
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 20
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 841
;841:			if (c < '0' || c > '9') {
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $224
ADDRLP4 0
INDIRI4
CNSTI4 57
LEI4 $222
LABELV $224
line 842
;842:				break;
ADDRGP4 $218
JUMPV
LABELV $222
line 844
;843:			}
;844:			c -= '0';
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 48
SUBI4
ASGNI4
line 845
;845:			value = value * 10 + c;
ADDRLP4 4
CNSTF4 1092616192
ADDRLP4 4
INDIRF4
MULF4
ADDRLP4 0
INDIRI4
CVIF4 4
ADDF4
ASGNF4
line 846
;846:		} while (1);
LABELV $220
ADDRGP4 $219
JUMPV
line 847
;847:	} else {
ADDRGP4 $218
JUMPV
LABELV $217
line 848
;848:		string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 849
;849:	}
LABELV $218
line 852
;850:
;851:	// check for decimal point
;852:	if (c == '.') {
ADDRLP4 0
INDIRI4
CNSTI4 46
NEI4 $225
line 855
;853:		double fraction;
;854:
;855:		fraction = 0.1;
ADDRLP4 20
CNSTF4 1036831949
ASGNF4
LABELV $227
line 856
;856:		do {
line 857
;857:			c = *string++;
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 24
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 24
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 858
;858:			if (c < '0' || c > '9') {
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $232
ADDRLP4 0
INDIRI4
CNSTI4 57
LEI4 $230
LABELV $232
line 859
;859:				break;
ADDRGP4 $229
JUMPV
LABELV $230
line 861
;860:			}
;861:			c -= '0';
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 48
SUBI4
ASGNI4
line 862
;862:			value += c * fraction;
ADDRLP4 4
ADDRLP4 4
INDIRF4
ADDRLP4 0
INDIRI4
CVIF4 4
ADDRLP4 20
INDIRF4
MULF4
ADDF4
ASGNF4
line 863
;863:			fraction *= 0.1;
ADDRLP4 20
CNSTF4 1036831949
ADDRLP4 20
INDIRF4
MULF4
ASGNF4
line 864
;864:		} while (1);
LABELV $228
ADDRGP4 $227
JUMPV
LABELV $229
line 866
;865:
;866:	}
LABELV $225
line 870
;867:
;868:	// not handling 10e10 notation...
;869:
;870:	return value * sign;
ADDRLP4 4
INDIRF4
ADDRLP4 8
INDIRF4
MULF4
RETF4
LABELV $206
endproc atof 32 0
export _atof
proc _atof 36 0
line 873
;871:}
;872:
;873:double _atof(const char **stringPtr) {
line 877
;874:	const char *string;
;875:	float sign;
;876:	float value;
;877:	int c = '0';
ADDRLP4 0
CNSTI4 48
ASGNI4
line 879
;878:
;879:	string = *stringPtr;
ADDRLP4 4
ADDRFP4 0
INDIRP4
INDIRP4
ASGNP4
ADDRGP4 $235
JUMPV
LABELV $234
line 882
;880:
;881:	// skip whitespace
;882:	while (*string <= ' ') {
line 883
;883:		if (!*string) {
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $237
line 884
;884:			*stringPtr = string;
ADDRFP4 0
INDIRP4
ADDRLP4 4
INDIRP4
ASGNP4
line 885
;885:			return 0;
CNSTF4 0
RETF4
ADDRGP4 $233
JUMPV
LABELV $237
line 887
;886:		}
;887:		string++;
ADDRLP4 4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 888
;888:	}
LABELV $235
line 882
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 32
LEI4 $234
line 891
;889:
;890:	// check sign
;891:	switch (*string) {
ADDRLP4 16
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 43
EQI4 $242
ADDRLP4 16
INDIRI4
CNSTI4 45
EQI4 $243
ADDRGP4 $239
JUMPV
LABELV $242
line 893
;892:		case '+':
;893:			string++;
ADDRLP4 4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 894
;894:			sign = 1;
ADDRLP4 12
CNSTF4 1065353216
ASGNF4
line 895
;895:			break;
ADDRGP4 $240
JUMPV
LABELV $243
line 897
;896:		case '-':
;897:			string++;
ADDRLP4 4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 898
;898:			sign = -1;
ADDRLP4 12
CNSTF4 3212836864
ASGNF4
line 899
;899:			break;
ADDRGP4 $240
JUMPV
LABELV $239
line 901
;900:		default:
;901:			sign = 1;
ADDRLP4 12
CNSTF4 1065353216
ASGNF4
line 902
;902:			break;
LABELV $240
line 906
;903:	}
;904:
;905:	// read digits
;906:	value = 0;
ADDRLP4 8
CNSTF4 0
ASGNF4
line 907
;907:	if (string[0] != '.') {
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 46
EQI4 $244
LABELV $246
line 908
;908:		do {
line 909
;909:			c = *string++;
ADDRLP4 24
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 24
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 24
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 910
;910:			if (c < '0' || c > '9') {
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $251
ADDRLP4 0
INDIRI4
CNSTI4 57
LEI4 $249
LABELV $251
line 911
;911:				break;
ADDRGP4 $248
JUMPV
LABELV $249
line 913
;912:			}
;913:			c -= '0';
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 48
SUBI4
ASGNI4
line 914
;914:			value = value * 10 + c;
ADDRLP4 8
CNSTF4 1092616192
ADDRLP4 8
INDIRF4
MULF4
ADDRLP4 0
INDIRI4
CVIF4 4
ADDF4
ASGNF4
line 915
;915:		} while (1);
LABELV $247
ADDRGP4 $246
JUMPV
LABELV $248
line 916
;916:	}
LABELV $244
line 919
;917:
;918:	// check for decimal point
;919:	if (c == '.') {
ADDRLP4 0
INDIRI4
CNSTI4 46
NEI4 $252
line 922
;920:		double fraction;
;921:
;922:		fraction = 0.1;
ADDRLP4 24
CNSTF4 1036831949
ASGNF4
LABELV $254
line 923
;923:		do {
line 924
;924:			c = *string++;
ADDRLP4 28
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 28
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 28
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 925
;925:			if (c < '0' || c > '9') {
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $259
ADDRLP4 0
INDIRI4
CNSTI4 57
LEI4 $257
LABELV $259
line 926
;926:				break;
ADDRGP4 $256
JUMPV
LABELV $257
line 928
;927:			}
;928:			c -= '0';
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 48
SUBI4
ASGNI4
line 929
;929:			value += c * fraction;
ADDRLP4 8
ADDRLP4 8
INDIRF4
ADDRLP4 0
INDIRI4
CVIF4 4
ADDRLP4 24
INDIRF4
MULF4
ADDF4
ASGNF4
line 930
;930:			fraction *= 0.1;
ADDRLP4 24
CNSTF4 1036831949
ADDRLP4 24
INDIRF4
MULF4
ASGNF4
line 931
;931:		} while (1);
LABELV $255
ADDRGP4 $254
JUMPV
LABELV $256
line 933
;932:
;933:	}
LABELV $252
line 936
;934:
;935:	// not handling 10e10 notation...
;936:	*stringPtr = string;
ADDRFP4 0
INDIRP4
ADDRLP4 4
INDIRP4
ASGNP4
line 938
;937:
;938:	return value * sign;
ADDRLP4 8
INDIRF4
ADDRLP4 12
INDIRF4
MULF4
RETF4
LABELV $233
endproc _atof 36 0
export strtod
proc strtod 60 12
line 955
;939:}
;940:
;941:/*
;942:==============
;943:strtod
;944:
;945:Without an errno variable, this is a fair bit less useful than it is in libc
;946:but it's still a fair bit more capable than atof or _atof
;947:Handles inf[inity], nan (ignoring case), hexadecimals, and decimals
;948:Handles decimal exponents like 10e10 and hex exponents like 0x7f8p20
;949:10e10 == 10000000000 (power of ten)
;950:0x7f8p20 == 0x7f800000 (decimal power of two)
;951:The variable pointed to by endptr will hold the location of the first character
;952:in the nptr string that was not used in the conversion
;953:==============
;954: */
;955:double strtod(const char *nptr, const char **endptr) {
line 957
;956:	double res;
;957:	qboolean neg = qfalse;
ADDRLP4 4
CNSTI4 0
ASGNI4
ADDRGP4 $262
JUMPV
LABELV $261
line 961
;958:
;959:	// skip whitespace
;960:	while (isspace(*nptr))
;961:		nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $262
line 960
ADDRLP4 8
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 32
EQI4 $261
ADDRLP4 8
INDIRI4
CNSTI4 12
EQI4 $261
ADDRLP4 8
INDIRI4
CNSTI4 10
EQI4 $261
ADDRLP4 8
INDIRI4
CNSTI4 13
EQI4 $261
ADDRLP4 8
INDIRI4
CNSTI4 9
EQI4 $261
ADDRLP4 8
INDIRI4
CNSTI4 11
EQI4 $261
line 964
;962:
;963:	// special string parsing
;964:	if (Q_strequaln(nptr, "nan", 3)) {
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 $266
ARGP4
CNSTI4 3
ARGI4
ADDRLP4 12
ADDRGP4 Q_stricmpn
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $264
line 966
;965:		floatint_t nan;
;966:		if (endptr == NULL) {
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $267
line 967
;967:			nan.ui = 0x7fffffff;
ADDRLP4 16
CNSTU4 2147483647
ASGNU4
line 968
;968:			return nan.f;
ADDRLP4 16
INDIRF4
RETF4
ADDRGP4 $260
JUMPV
LABELV $267
line 970
;969:		}
;970:		*endptr = &nptr[3];
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
CNSTI4 3
ADDP4
ASGNP4
line 976
;971:		// nan can be followed by a bracketed number (in hex, octal,
;972:		// or decimal) which is then put in the mantissa
;973:		// this can be used to generate signalling or quiet NaNs, for
;974:		// example (though I doubt it'll ever be used)
;975:		// note that nan(0) is infinity!
;976:		if (nptr[3] == '(') {
ADDRFP4 0
INDIRP4
CNSTI4 3
ADDP4
INDIRI1
CVII4 1
CNSTI4 40
NEI4 $269
line 978
;977:			const char *end;
;978:			int mantissa = strtol(&nptr[4], &end, 0);
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRLP4 24
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 28
ADDRGP4 strtol
CALLI4
ASGNI4
ADDRLP4 20
ADDRLP4 28
INDIRI4
ASGNI4
line 979
;979:			if (*end == ')') {
ADDRLP4 24
INDIRP4
INDIRI1
CVII4 1
CNSTI4 41
NEI4 $271
line 980
;980:				nan.ui = 0x7f800000 | (mantissa & 0x7fffff);
ADDRLP4 16
ADDRLP4 20
INDIRI4
CNSTI4 8388607
BANDI4
CNSTI4 2139095040
BORI4
CVIU4 4
ASGNU4
line 981
;981:				if (endptr)
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $273
line 982
;982:					*endptr = &end[1];
ADDRFP4 4
INDIRP4
ADDRLP4 24
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $273
line 983
;983:				return nan.f;
ADDRLP4 16
INDIRF4
RETF4
ADDRGP4 $260
JUMPV
LABELV $271
line 985
;984:			}
;985:		}
LABELV $269
line 986
;986:		nan.ui = 0x7fffffff;
ADDRLP4 16
CNSTU4 2147483647
ASGNU4
line 987
;987:		return nan.f;
ADDRLP4 16
INDIRF4
RETF4
ADDRGP4 $260
JUMPV
LABELV $264
line 989
;988:	}
;989:	if (Q_strequaln(nptr, "inf", 3)) {
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 $277
ARGP4
CNSTI4 3
ARGI4
ADDRLP4 16
ADDRGP4 Q_stricmpn
CALLI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $275
line 991
;990:		floatint_t inf;
;991:		inf.ui = 0x7f800000;
ADDRLP4 20
CNSTU4 2139095040
ASGNU4
line 992
;992:		if (endptr == NULL)
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $278
line 993
;993:			return inf.f;
ADDRLP4 20
INDIRF4
RETF4
ADDRGP4 $260
JUMPV
LABELV $278
line 994
;994:		if (Q_strequaln(&nptr[3], "inity", 5))
ADDRFP4 0
INDIRP4
CNSTI4 3
ADDP4
ARGP4
ADDRGP4 $282
ARGP4
CNSTI4 5
ARGI4
ADDRLP4 24
ADDRGP4 Q_stricmpn
CALLI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 0
NEI4 $280
line 995
;995:			*endptr = &nptr[8];
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
ASGNP4
ADDRGP4 $281
JUMPV
LABELV $280
line 997
;996:		else
;997:			*endptr = &nptr[3];
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
CNSTI4 3
ADDP4
ASGNP4
LABELV $281
line 998
;998:		return inf.f;
ADDRLP4 20
INDIRF4
RETF4
ADDRGP4 $260
JUMPV
LABELV $275
line 1003
;999:	}
;1000:
;1001:	// normal numeric parsing
;1002:	// sign
;1003:	if (*nptr == '-') {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 45
NEI4 $283
line 1004
;1004:		nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1005
;1005:		neg = qtrue;
ADDRLP4 4
CNSTI4 1
ASGNI4
line 1006
;1006:	} else if (*nptr == '+')
ADDRGP4 $284
JUMPV
LABELV $283
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 43
NEI4 $285
line 1007
;1007:		nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $285
LABELV $284
line 1009
;1008:	// hex
;1009:	if (Q_strequaln(nptr, "0x", 2)) {
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 $289
ARGP4
CNSTI4 2
ARGI4
ADDRLP4 20
ADDRGP4 Q_stricmpn
CALLI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 0
NEI4 $287
line 1011
;1010:		// track if we use any digits
;1011:		const char *s = &nptr[1], *end = s;
ADDRLP4 28
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 24
ADDRLP4 28
INDIRP4
ASGNP4
line 1012
;1012:		nptr += 2;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 2
ADDP4
ASGNP4
line 1013
;1013:		res = 0;
ADDRLP4 0
CNSTF4 0
ASGNF4
ADDRGP4 $291
JUMPV
LABELV $290
line 1014
;1014:		while (qtrue) {
line 1015
;1015:			if (isdigit(*nptr))
ADDRLP4 32
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 48
LTI4 $293
ADDRLP4 32
INDIRI4
CNSTI4 57
GTI4 $293
line 1016
;1016:				res = 16 * res + (*nptr++ -'0');
ADDRLP4 36
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 36
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
CNSTF4 1098907648
ADDRLP4 0
INDIRF4
MULF4
ADDRLP4 36
INDIRP4
INDIRI1
CVII4 1
CNSTI4 48
SUBI4
CVIF4 4
ADDF4
ASGNF4
ADDRGP4 $294
JUMPV
LABELV $293
line 1017
;1017:			else if (*nptr >= 'A' && *nptr <= 'F')
ADDRLP4 40
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 40
INDIRI4
CNSTI4 65
LTI4 $295
ADDRLP4 40
INDIRI4
CNSTI4 70
GTI4 $295
line 1018
;1018:				res = 16 * res + 10 + *nptr++ -'A';
ADDRLP4 44
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 44
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
CNSTF4 1098907648
ADDRLP4 0
INDIRF4
MULF4
CNSTF4 1092616192
ADDF4
ADDRLP4 44
INDIRP4
INDIRI1
CVII4 1
CVIF4 4
ADDF4
CNSTF4 1115815936
SUBF4
ASGNF4
ADDRGP4 $296
JUMPV
LABELV $295
line 1019
;1019:			else if (*nptr >= 'a' && *nptr <= 'f')
ADDRLP4 48
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 48
INDIRI4
CNSTI4 97
LTI4 $292
ADDRLP4 48
INDIRI4
CNSTI4 102
GTI4 $292
line 1020
;1020:				res = 16 * res + 10 + *nptr++ -'a';
ADDRLP4 52
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 52
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
CNSTF4 1098907648
ADDRLP4 0
INDIRF4
MULF4
CNSTF4 1092616192
ADDF4
ADDRLP4 52
INDIRP4
INDIRI1
CVII4 1
CVIF4 4
ADDF4
CNSTF4 1120010240
SUBF4
ASGNF4
line 1022
;1021:			else
;1022:				break;
LABELV $298
LABELV $296
LABELV $294
line 1023
;1023:		}
LABELV $291
line 1014
ADDRGP4 $290
JUMPV
LABELV $292
line 1025
;1024:		// if nptr moved, save it
;1025:		if (end + 1 < nptr)
ADDRLP4 24
INDIRP4
CNSTI4 1
ADDP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
GEU4 $299
line 1026
;1026:			end = nptr;
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $299
line 1027
;1027:		if (*nptr == '.') {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 46
NEI4 $301
line 1029
;1028:			float place;
;1029:			nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1034
;1030:			// 1.0 / 16.0 == 0.0625
;1031:			// I don't expect the float accuracy to hold out for
;1032:			// very long but since we need to know the length of
;1033:			// the string anyway we keep on going regardless
;1034:			for (place = 0.0625;; place /= 16.0) {
ADDRLP4 32
CNSTF4 1031798784
ASGNF4
LABELV $303
line 1035
;1035:				if (isdigit(*nptr))
ADDRLP4 36
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 36
INDIRI4
CNSTI4 48
LTI4 $307
ADDRLP4 36
INDIRI4
CNSTI4 57
GTI4 $307
line 1036
;1036:					res += place * (*nptr++ -'0');
ADDRLP4 40
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 40
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 0
INDIRF4
ADDRLP4 32
INDIRF4
ADDRLP4 40
INDIRP4
INDIRI1
CVII4 1
CNSTI4 48
SUBI4
CVIF4 4
MULF4
ADDF4
ASGNF4
ADDRGP4 $308
JUMPV
LABELV $307
line 1037
;1037:				else if (*nptr >= 'A' && *nptr <= 'F')
ADDRLP4 44
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 44
INDIRI4
CNSTI4 65
LTI4 $309
ADDRLP4 44
INDIRI4
CNSTI4 70
GTI4 $309
line 1038
;1038:					res += place * (10 + *nptr++ -'A');
ADDRLP4 48
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 48
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 0
INDIRF4
ADDRLP4 32
INDIRF4
ADDRLP4 48
INDIRP4
INDIRI1
CVII4 1
CNSTI4 10
ADDI4
CNSTI4 65
SUBI4
CVIF4 4
MULF4
ADDF4
ASGNF4
ADDRGP4 $310
JUMPV
LABELV $309
line 1039
;1039:				else if (*nptr >= 'a' && *nptr <= 'f')
ADDRLP4 52
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 52
INDIRI4
CNSTI4 97
LTI4 $305
ADDRLP4 52
INDIRI4
CNSTI4 102
GTI4 $305
line 1040
;1040:					res += place * (10 + *nptr++ -'a');
ADDRLP4 56
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 56
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 0
INDIRF4
ADDRLP4 32
INDIRF4
ADDRLP4 56
INDIRP4
INDIRI1
CVII4 1
CNSTI4 10
ADDI4
CNSTI4 97
SUBI4
CVIF4 4
MULF4
ADDF4
ASGNF4
line 1042
;1041:				else
;1042:					break;
LABELV $312
LABELV $310
LABELV $308
line 1043
;1043:			}
LABELV $304
line 1034
ADDRLP4 32
ADDRLP4 32
INDIRF4
CNSTF4 1098907648
DIVF4
ASGNF4
ADDRGP4 $303
JUMPV
LABELV $305
line 1044
;1044:			if (end < nptr)
ADDRLP4 24
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
GEU4 $313
line 1045
;1045:				end = nptr;
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $313
line 1046
;1046:		}
LABELV $301
line 1051
;1047:		// parse an optional exponent, representing multiplication
;1048:		// by a power of two
;1049:		// exponents are only valid if we encountered at least one
;1050:		// digit already (and have therefore set end to something)
;1051:		if (end != s && tolower(*nptr) == 'p') {
ADDRLP4 24
INDIRP4
CVPU4 4
ADDRLP4 28
INDIRP4
CVPU4 4
EQU4 $315
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 32
ADDRGP4 tolower
CALLI4
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 112
NEI4 $315
line 1055
;1052:			int exp;
;1053:			// apparently (confusingly) the exponent should be
;1054:			// decimal
;1055:			exp = strtol(&nptr[1], &end, 10);
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ARGP4
ADDRLP4 24
ARGP4
CNSTI4 10
ARGI4
ADDRLP4 40
ADDRGP4 strtol
CALLI4
ASGNI4
ADDRLP4 36
ADDRLP4 40
INDIRI4
ASGNI4
line 1056
;1056:			if (&nptr[1] == end) {
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
CVPU4 4
ADDRLP4 24
INDIRP4
CVPU4 4
NEU4 $317
line 1058
;1057:				// no exponent
;1058:				if (endptr)
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $319
line 1059
;1059:					*endptr = nptr;
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $319
line 1060
;1060:				return res;
ADDRLP4 0
INDIRF4
RETF4
ADDRGP4 $260
JUMPV
LABELV $317
line 1063
;1061:			}
;1062:
;1063:			res *= powN(2, exp);
CNSTF4 1073741824
ARGF4
ADDRLP4 36
INDIRI4
ARGI4
ADDRLP4 44
ADDRGP4 powN
CALLF4
ASGNF4
ADDRLP4 0
ADDRLP4 0
INDIRF4
ADDRLP4 44
INDIRF4
MULF4
ASGNF4
line 1064
;1064:		}
LABELV $315
line 1065
;1065:		if (endptr)
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $321
line 1066
;1066:			*endptr = end;
ADDRFP4 4
INDIRP4
ADDRLP4 24
INDIRP4
ASGNP4
LABELV $321
line 1067
;1067:		return res;
ADDRLP4 0
INDIRF4
RETF4
ADDRGP4 $260
JUMPV
LABELV $287
line 1069
;1068:	}		// decimal
;1069:	else {
line 1071
;1070:		// track if we find any digits
;1071:		const char *end = nptr, *p = nptr;
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 28
ADDRFP4 0
INDIRP4
ASGNP4
line 1073
;1072:		// this is most of the work
;1073:		for (res = 0; isdigit(*nptr);
ADDRLP4 0
CNSTF4 0
ASGNF4
ADDRGP4 $326
JUMPV
LABELV $323
line 1074
;1074:				res = 10 * res + *nptr++ -'0');
LABELV $324
ADDRLP4 32
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 32
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
CNSTF4 1092616192
ADDRLP4 0
INDIRF4
MULF4
ADDRLP4 32
INDIRP4
INDIRI1
CVII4 1
CVIF4 4
ADDF4
CNSTF4 1111490560
SUBF4
ASGNF4
LABELV $326
line 1073
ADDRLP4 36
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 36
INDIRI4
CNSTI4 48
LTI4 $327
ADDRLP4 36
INDIRI4
CNSTI4 57
LEI4 $323
LABELV $327
line 1076
;1075:		// if nptr moved, we read something
;1076:		if (end < nptr)
ADDRLP4 24
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
GEU4 $328
line 1077
;1077:			end = nptr;
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $328
line 1078
;1078:		if (*nptr == '.') {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 46
NEI4 $330
line 1081
;1079:			// fractional part
;1080:			float place;
;1081:			nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1082
;1082:			for (place = 0.1; isdigit(*nptr); place /= 10.0)
ADDRLP4 40
CNSTF4 1036831949
ASGNF4
ADDRGP4 $335
JUMPV
LABELV $332
line 1083
;1083:				res += (*nptr++ -'0') * place;
ADDRLP4 44
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 44
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 0
INDIRF4
ADDRLP4 44
INDIRP4
INDIRI1
CVII4 1
CNSTI4 48
SUBI4
CVIF4 4
ADDRLP4 40
INDIRF4
MULF4
ADDF4
ASGNF4
LABELV $333
line 1082
ADDRLP4 40
ADDRLP4 40
INDIRF4
CNSTF4 1092616192
DIVF4
ASGNF4
LABELV $335
ADDRLP4 48
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 48
INDIRI4
CNSTI4 48
LTI4 $336
ADDRLP4 48
INDIRI4
CNSTI4 57
LEI4 $332
LABELV $336
line 1085
;1084:			// if nptr moved, we read something
;1085:			if (end + 1 < nptr)
ADDRLP4 24
INDIRP4
CNSTI4 1
ADDP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
GEU4 $337
line 1086
;1086:				end = nptr;
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $337
line 1087
;1087:		}
LABELV $330
line 1091
;1088:		// exponent
;1089:		// meaningless without having already read digits, so check
;1090:		// we've set end to something
;1091:		if (p != end && tolower(*nptr) == 'e') {
ADDRLP4 28
INDIRP4
CVPU4 4
ADDRLP4 24
INDIRP4
CVPU4 4
EQU4 $339
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 40
ADDRGP4 tolower
CALLI4
ASGNI4
ADDRLP4 40
INDIRI4
CNSTI4 101
NEI4 $339
line 1093
;1092:			int exp;
;1093:			exp = strtol(&nptr[1], &end, 10);
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ARGP4
ADDRLP4 24
ARGP4
CNSTI4 10
ARGI4
ADDRLP4 48
ADDRGP4 strtol
CALLI4
ASGNI4
ADDRLP4 44
ADDRLP4 48
INDIRI4
ASGNI4
line 1094
;1094:			if (&nptr[1] == end) {
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
CVPU4 4
ADDRLP4 24
INDIRP4
CVPU4 4
NEU4 $341
line 1096
;1095:				// no exponent
;1096:				if (endptr)
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $343
line 1097
;1097:					*endptr = nptr;
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $343
line 1098
;1098:				return res;
ADDRLP4 0
INDIRF4
RETF4
ADDRGP4 $260
JUMPV
LABELV $341
line 1101
;1099:			}
;1100:
;1101:			res *= powN(10, exp);
CNSTF4 1092616192
ARGF4
ADDRLP4 44
INDIRI4
ARGI4
ADDRLP4 52
ADDRGP4 powN
CALLF4
ASGNF4
ADDRLP4 0
ADDRLP4 0
INDIRF4
ADDRLP4 52
INDIRF4
MULF4
ASGNF4
line 1102
;1102:		}
LABELV $339
line 1103
;1103:		if (endptr)
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $345
line 1104
;1104:			*endptr = end;
ADDRFP4 4
INDIRP4
ADDRLP4 24
INDIRP4
ASGNP4
LABELV $345
line 1105
;1105:		return res;
ADDRLP4 0
INDIRF4
RETF4
LABELV $260
endproc strtod 60 12
export atoi
proc atoi 28 0
line 1109
;1106:	}
;1107:}
;1108:
;1109:int atoi(const char *string) {
ADDRGP4 $349
JUMPV
LABELV $348
line 1116
;1110:	int sign;
;1111:	int value;
;1112:	int c;
;1113:
;1114:
;1115:	// skip whitespace
;1116:	while (*string <= ' ') {
line 1117
;1117:		if (!*string) {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $351
line 1118
;1118:			return 0;
CNSTI4 0
RETI4
ADDRGP4 $347
JUMPV
LABELV $351
line 1120
;1119:		}
;1120:		string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1121
;1121:	}
LABELV $349
line 1116
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 32
LEI4 $348
line 1124
;1122:
;1123:	// check sign
;1124:	switch (*string) {
ADDRLP4 12
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 43
EQI4 $356
ADDRLP4 12
INDIRI4
CNSTI4 45
EQI4 $357
ADDRGP4 $353
JUMPV
LABELV $356
line 1126
;1125:		case '+':
;1126:			string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1127
;1127:			sign = 1;
ADDRLP4 8
CNSTI4 1
ASGNI4
line 1128
;1128:			break;
ADDRGP4 $354
JUMPV
LABELV $357
line 1130
;1129:		case '-':
;1130:			string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1131
;1131:			sign = -1;
ADDRLP4 8
CNSTI4 -1
ASGNI4
line 1132
;1132:			break;
ADDRGP4 $354
JUMPV
LABELV $353
line 1134
;1133:		default:
;1134:			sign = 1;
ADDRLP4 8
CNSTI4 1
ASGNI4
line 1135
;1135:			break;
LABELV $354
line 1139
;1136:	}
;1137:
;1138:	// read digits
;1139:	value = 0;
ADDRLP4 4
CNSTI4 0
ASGNI4
LABELV $358
line 1140
;1140:	do {
line 1141
;1141:		c = *string++;
ADDRLP4 20
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 20
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 20
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 1142
;1142:		if (c < '0' || c > '9') {
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $363
ADDRLP4 0
INDIRI4
CNSTI4 57
LEI4 $361
LABELV $363
line 1143
;1143:			break;
ADDRGP4 $360
JUMPV
LABELV $361
line 1145
;1144:		}
;1145:		c -= '0';
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 48
SUBI4
ASGNI4
line 1146
;1146:		value = value * 10 + c;
ADDRLP4 4
CNSTI4 10
ADDRLP4 4
INDIRI4
MULI4
ADDRLP4 0
INDIRI4
ADDI4
ASGNI4
line 1147
;1147:	} while (1);
LABELV $359
ADDRGP4 $358
JUMPV
LABELV $360
line 1151
;1148:
;1149:	// not handling 10e10 notation...
;1150:
;1151:	return value * sign;
ADDRLP4 4
INDIRI4
ADDRLP4 8
INDIRI4
MULI4
RETI4
LABELV $347
endproc atoi 28 0
export _atoi
proc _atoi 32 0
line 1154
;1152:}
;1153:
;1154:int _atoi(const char **stringPtr) {
line 1160
;1155:	int sign;
;1156:	int value;
;1157:	int c;
;1158:	const char *string;
;1159:
;1160:	string = *stringPtr;
ADDRLP4 4
ADDRFP4 0
INDIRP4
INDIRP4
ASGNP4
ADDRGP4 $366
JUMPV
LABELV $365
line 1163
;1161:
;1162:	// skip whitespace
;1163:	while (*string <= ' ') {
line 1164
;1164:		if (!*string) {
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $368
line 1165
;1165:			return 0;
CNSTI4 0
RETI4
ADDRGP4 $364
JUMPV
LABELV $368
line 1167
;1166:		}
;1167:		string++;
ADDRLP4 4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1168
;1168:	}
LABELV $366
line 1163
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 32
LEI4 $365
line 1171
;1169:
;1170:	// check sign
;1171:	switch (*string) {
ADDRLP4 16
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 43
EQI4 $373
ADDRLP4 16
INDIRI4
CNSTI4 45
EQI4 $374
ADDRGP4 $370
JUMPV
LABELV $373
line 1173
;1172:		case '+':
;1173:			string++;
ADDRLP4 4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1174
;1174:			sign = 1;
ADDRLP4 12
CNSTI4 1
ASGNI4
line 1175
;1175:			break;
ADDRGP4 $371
JUMPV
LABELV $374
line 1177
;1176:		case '-':
;1177:			string++;
ADDRLP4 4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1178
;1178:			sign = -1;
ADDRLP4 12
CNSTI4 -1
ASGNI4
line 1179
;1179:			break;
ADDRGP4 $371
JUMPV
LABELV $370
line 1181
;1180:		default:
;1181:			sign = 1;
ADDRLP4 12
CNSTI4 1
ASGNI4
line 1182
;1182:			break;
LABELV $371
line 1186
;1183:	}
;1184:
;1185:	// read digits
;1186:	value = 0;
ADDRLP4 8
CNSTI4 0
ASGNI4
LABELV $375
line 1187
;1187:	do {
line 1188
;1188:		c = *string++;
ADDRLP4 24
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 24
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 24
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 1189
;1189:		if (c < '0' || c > '9') {
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $380
ADDRLP4 0
INDIRI4
CNSTI4 57
LEI4 $378
LABELV $380
line 1190
;1190:			break;
ADDRGP4 $377
JUMPV
LABELV $378
line 1192
;1191:		}
;1192:		c -= '0';
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 48
SUBI4
ASGNI4
line 1193
;1193:		value = value * 10 + c;
ADDRLP4 8
CNSTI4 10
ADDRLP4 8
INDIRI4
MULI4
ADDRLP4 0
INDIRI4
ADDI4
ASGNI4
line 1194
;1194:	} while (1);
LABELV $376
ADDRGP4 $375
JUMPV
LABELV $377
line 1198
;1195:
;1196:	// not handling 10e10 notation...
;1197:
;1198:	*stringPtr = string;
ADDRFP4 0
INDIRP4
ADDRLP4 4
INDIRP4
ASGNP4
line 1200
;1199:
;1200:	return value * sign;
ADDRLP4 8
INDIRI4
ADDRLP4 12
INDIRI4
MULI4
RETI4
LABELV $364
endproc _atoi 32 0
export strtol
proc strtol 32 0
line 1213
;1201:}
;1202:
;1203:/*
;1204:==============
;1205:strtol
;1206:
;1207:Handles any base from 2 to 36. If base is 0 then it guesses
;1208:decimal, hex, or octal based on the format of the number (leading 0 or 0x)
;1209:Will not overflow - returns LONG_MIN or LONG_MAX as appropriate
;1210: *endptr is set to the location of the first character not used
;1211:==============
;1212: */
;1213:long strtol(const char *nptr, const char **endptr, int base) {
line 1215
;1214:	long res;
;1215:	qboolean pos = qtrue;
ADDRLP4 4
CNSTI4 1
ASGNI4
line 1217
;1216:
;1217:	if (endptr)
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $382
line 1218
;1218:		*endptr = nptr;
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $382
line 1221
;1219:	// bases other than 0, 2, 8, 16 are very rarely used, but they're
;1220:	// not much extra effort to support
;1221:	if (base < 0 || base == 1 || base > 36)
ADDRLP4 8
ADDRFP4 8
INDIRI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
LTI4 $387
ADDRLP4 8
INDIRI4
CNSTI4 1
EQI4 $387
ADDRLP4 8
INDIRI4
CNSTI4 36
LEI4 $389
LABELV $387
line 1222
;1222:		return 0;
CNSTI4 0
RETI4
ADDRGP4 $381
JUMPV
LABELV $388
line 1225
;1223:	// skip leading whitespace
;1224:	while (isspace(*nptr))
;1225:		nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $389
line 1224
ADDRLP4 12
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 32
EQI4 $388
ADDRLP4 12
INDIRI4
CNSTI4 12
EQI4 $388
ADDRLP4 12
INDIRI4
CNSTI4 10
EQI4 $388
ADDRLP4 12
INDIRI4
CNSTI4 13
EQI4 $388
ADDRLP4 12
INDIRI4
CNSTI4 9
EQI4 $388
ADDRLP4 12
INDIRI4
CNSTI4 11
EQI4 $388
line 1227
;1226:	// sign
;1227:	if (*nptr == '-') {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 45
NEI4 $391
line 1228
;1228:		nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1229
;1229:		pos = qfalse;
ADDRLP4 4
CNSTI4 0
ASGNI4
line 1230
;1230:	} else if (*nptr == '+')
ADDRGP4 $392
JUMPV
LABELV $391
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 43
NEI4 $393
line 1231
;1231:		nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $393
LABELV $392
line 1233
;1232:	// look for base-identifying sequences e.g. 0x for hex, 0 for octal
;1233:	if (nptr[0] == '0') {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 48
NEI4 $395
line 1234
;1234:		nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1236
;1235:		// 0 is always a valid digit
;1236:		if (endptr)
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $397
line 1237
;1237:			*endptr = nptr;
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $397
line 1238
;1238:		if (*nptr == 'x' || *nptr == 'X') {
ADDRLP4 16
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 120
EQI4 $401
ADDRLP4 16
INDIRI4
CNSTI4 88
NEI4 $399
LABELV $401
line 1239
;1239:			if (base != 0 && base != 16) {
ADDRLP4 20
ADDRFP4 8
INDIRI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 0
EQI4 $402
ADDRLP4 20
INDIRI4
CNSTI4 16
EQI4 $402
line 1241
;1240:				// can't be hex, reject x (accept 0)
;1241:				if (endptr)
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $404
line 1242
;1242:					*endptr = nptr;
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $404
line 1243
;1243:				return 0;
CNSTI4 0
RETI4
ADDRGP4 $381
JUMPV
LABELV $402
line 1245
;1244:			}
;1245:			nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1246
;1246:			base = 16;
ADDRFP4 8
CNSTI4 16
ASGNI4
line 1247
;1247:		} else if (base == 0)
ADDRGP4 $400
JUMPV
LABELV $399
ADDRFP4 8
INDIRI4
CNSTI4 0
NEI4 $406
line 1248
;1248:			base = 8;
ADDRFP4 8
CNSTI4 8
ASGNI4
LABELV $406
LABELV $400
line 1249
;1249:	}
LABELV $395
line 1250
;1250:	if (base == 0)
ADDRFP4 8
INDIRI4
CNSTI4 0
NEI4 $408
line 1251
;1251:		base = 10;
ADDRFP4 8
CNSTI4 10
ASGNI4
LABELV $408
line 1252
;1252:	res = 0;
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $411
JUMPV
LABELV $410
line 1253
;1253:	while (qtrue) {
line 1255
;1254:		int val;
;1255:		if (isdigit(*nptr))
ADDRLP4 20
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 48
LTI4 $413
ADDRLP4 20
INDIRI4
CNSTI4 57
GTI4 $413
line 1256
;1256:			val = *nptr - '0';
ADDRLP4 16
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 48
SUBI4
ASGNI4
ADDRGP4 $414
JUMPV
LABELV $413
line 1257
;1257:		else if (islower(*nptr))
ADDRLP4 24
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 97
LTI4 $415
ADDRLP4 24
INDIRI4
CNSTI4 122
GTI4 $415
line 1258
;1258:			val = 10 + *nptr - 'a';
ADDRLP4 16
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 10
ADDI4
CNSTI4 97
SUBI4
ASGNI4
ADDRGP4 $416
JUMPV
LABELV $415
line 1259
;1259:		else if (isupper(*nptr))
ADDRLP4 28
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 65
LTI4 $412
ADDRLP4 28
INDIRI4
CNSTI4 90
GTI4 $412
line 1260
;1260:			val = 10 + *nptr - 'A';
ADDRLP4 16
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 10
ADDI4
CNSTI4 65
SUBI4
ASGNI4
line 1262
;1261:		else
;1262:			break;
LABELV $418
LABELV $416
LABELV $414
line 1263
;1263:		if (val >= base)
ADDRLP4 16
INDIRI4
ADDRFP4 8
INDIRI4
LTI4 $419
line 1264
;1264:			break;
ADDRGP4 $412
JUMPV
LABELV $419
line 1267
;1265:		// we go negative because LONG_MIN is further from 0 than
;1266:		// LONG_MAX
;1267:		if (res < (LONG_MIN + val) / base)
ADDRLP4 0
INDIRI4
ADDRLP4 16
INDIRI4
CNSTI4 -2147483648
ADDI4
ADDRFP4 8
INDIRI4
DIVI4
GEI4 $421
line 1268
;1268:			res = LONG_MIN; // overflow
ADDRLP4 0
CNSTI4 -2147483648
ASGNI4
ADDRGP4 $422
JUMPV
LABELV $421
line 1270
;1269:		else
;1270:			res = res * base - val;
ADDRLP4 0
ADDRLP4 0
INDIRI4
ADDRFP4 8
INDIRI4
MULI4
ADDRLP4 16
INDIRI4
SUBI4
ASGNI4
LABELV $422
line 1271
;1271:		nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1272
;1272:		if (endptr)
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $423
line 1273
;1273:			*endptr = nptr;
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $423
line 1274
;1274:	}
LABELV $411
line 1253
ADDRGP4 $410
JUMPV
LABELV $412
line 1275
;1275:	if (pos) {
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $425
line 1277
;1276:		// can't represent LONG_MIN positive
;1277:		if (res == LONG_MIN)
ADDRLP4 0
INDIRI4
CNSTI4 -2147483648
NEI4 $427
line 1278
;1278:			res = LONG_MAX;
ADDRLP4 0
CNSTI4 2147483647
ASGNI4
ADDRGP4 $428
JUMPV
LABELV $427
line 1280
;1279:		else
;1280:			res = -res;
ADDRLP4 0
ADDRLP4 0
INDIRI4
NEGI4
ASGNI4
LABELV $428
line 1281
;1281:	}
LABELV $425
line 1282
;1282:	return res;
ADDRLP4 0
INDIRI4
RETI4
LABELV $381
endproc strtol 32 0
export abs
proc abs 4 0
line 1285
;1283:}
;1284:
;1285:int abs(int n) {
line 1286
;1286:	return n < 0 ? -n : n;
ADDRFP4 0
INDIRI4
CNSTI4 0
GEI4 $431
ADDRLP4 0
ADDRFP4 0
INDIRI4
NEGI4
ASGNI4
ADDRGP4 $432
JUMPV
LABELV $431
ADDRLP4 0
ADDRFP4 0
INDIRI4
ASGNI4
LABELV $432
ADDRLP4 0
INDIRI4
RETI4
LABELV $429
endproc abs 4 0
export fabs
proc fabs 4 0
line 1289
;1287:}
;1288:
;1289:double fabs(double x) {
line 1290
;1290:	return x < 0 ? -x : x;
ADDRFP4 0
INDIRF4
CNSTF4 0
GEF4 $435
ADDRLP4 0
ADDRFP4 0
INDIRF4
NEGF4
ASGNF4
ADDRGP4 $436
JUMPV
LABELV $435
ADDRLP4 0
ADDRFP4 0
INDIRF4
ASGNF4
LABELV $436
ADDRLP4 0
INDIRF4
RETF4
LABELV $433
endproc fabs 4 0
proc dopr 276 32
line 1428
;1291:}
;1292:
;1293:
;1294:
;1295://=========================================================
;1296:
;1297:/* 
;1298: * New implementation by Patrick Powell and others for vsnprintf.
;1299: * Supports length checking in strings.
;1300: */
;1301:
;1302:/*
;1303: * Copyright Patrick Powell 1995
;1304: * This code is based on code written by Patrick Powell (papowell@astart.com)
;1305: * It may be used for any purpose as long as this notice remains intact
;1306: * on all source code distributions
;1307: */
;1308:
;1309:/**************************************************************
;1310: * Original:
;1311: * Patrick Powell Tue Apr 11 09:48:21 PDT 1995
;1312: * A bombproof version of doprnt (dopr) included.
;1313: * Sigh.  This sort of thing is always nasty do deal with.  Note that
;1314: * the version here does not include floating point...
;1315: *
;1316: * snprintf() is used instead of sprintf() as it does limit checks
;1317: * for string length.  This covers a nasty loophole.
;1318: *
;1319: * The other functions are there to prevent NULL pointers from
;1320: * causing nast effects.
;1321: *
;1322: * More Recently:
;1323: *  Brandon Long <blong@fiction.net> 9/15/96 for mutt 0.43
;1324: *  This was ugly.  It is still ugly.  I opted out of floating point
;1325: *  numbers, but the formatter understands just about everything
;1326: *  from the normal C string format, at least as far as I can tell from
;1327: *  the Solaris 2.5 printf(3S) man page.
;1328: *
;1329: *  Brandon Long <blong@fiction.net> 10/22/97 for mutt 0.87.1
;1330: *    Ok, added some minimal floating point support, which means this
;1331: *    probably requires libm on most operating systems.  Don't yet
;1332: *    support the exponent (e,E) and sigfig (g,G).  Also, fmtint()
;1333: *    was pretty badly broken, it just wasn't being exercised in ways
;1334: *    which showed it, so that's been fixed.  Also, formated the code
;1335: *    to mutt conventions, and removed dead code left over from the
;1336: *    original.  Also, there is now a builtin-test, just compile with:
;1337: *           gcc -DTEST_SNPRINTF -o snprintf snprintf.c -lm
;1338: *    and run snprintf for results.
;1339: * 
;1340: *  Thomas Roessler <roessler@guug.de> 01/27/98 for mutt 0.89i
;1341: *    The PGP code was using unsigned hexadecimal formats. 
;1342: *    Unfortunately, unsigned formats simply didn't work.
;1343: *
;1344: *  Michael Elkins <me@cs.hmc.edu> 03/05/98 for mutt 0.90.8
;1345: *    The original code assumed that both snprintf() and vsnprintf() were
;1346: *    missing.  Some systems only have snprintf() but not vsnprintf(), so
;1347: *    the code is now broken down under HAVE_SNPRINTF and HAVE_VSNPRINTF.
;1348: *
;1349: *  Andrew Tridgell (tridge@samba.org) Oct 1998
;1350: *    fixed handling of %.0f
;1351: *    added test for HAVE_LONG_DOUBLE
;1352: *
;1353: *  Russ Allbery <rra@stanford.edu> 2000-08-26
;1354: *    fixed return value to comply with C99
;1355: *    fixed handling of snprintf(NULL, ...)
;1356: *
;1357: *  Hrvoje Niksic <hniksic@arsdigita.com> 2000-11-04
;1358: *    include <config.h> instead of "config.h".
;1359: *    moved TEST_SNPRINTF stuff out of HAVE_SNPRINTF ifdef.
;1360: *    include <stdio.h> for NULL.
;1361: *    added support and test cases for long long.
;1362: *    don't declare argument types to (v)snprintf if stdarg is not used.
;1363: *    use int instead of short int as 2nd arg to va_arg.
;1364: *
;1365: **************************************************************/
;1366:
;1367:/* BDR 2002-01-13  %e and %g were being ignored.  Now do something,
;1368:   if not necessarily correctly */
;1369:
;1370:#if (SIZEOF_LONG_DOUBLE > 0)
;1371:/* #ifdef HAVE_LONG_DOUBLE */
;1372:#define LDOUBLE long double
;1373:#else
;1374:#define LDOUBLE double
;1375:#endif
;1376:
;1377:#if (SIZEOF_LONG_LONG > 0)
;1378:/* #ifdef HAVE_LONG_LONG */
;1379:#define LLONG long long
;1380:#else
;1381:#define LLONG long
;1382:#endif
;1383:
;1384:static int dopr(char *buffer, size_t maxlen, const char *format,
;1385:		va_list args);
;1386:static int fmtstr(char *buffer, size_t *currlen, size_t maxlen,
;1387:		char *value, int flags, int min, int max);
;1388:static int fmtint(char *buffer, size_t *currlen, size_t maxlen,
;1389:		LLONG value, int base, int min, int max, int flags);
;1390:static int fmtfp(char *buffer, size_t *currlen, size_t maxlen,
;1391:		LDOUBLE fvalue, int min, int max, int flags);
;1392:static int dopr_outch(char *buffer, size_t *currlen, size_t maxlen, char c);
;1393:
;1394:/*
;1395: * dopr(): poor man's version of doprintf
;1396: */
;1397:
;1398:/* format read states */
;1399:#define DP_S_DEFAULT 0
;1400:#define DP_S_FLAGS   1
;1401:#define DP_S_MIN     2
;1402:#define DP_S_DOT     3
;1403:#define DP_S_MAX     4
;1404:#define DP_S_MOD     5
;1405:#define DP_S_MOD_L   6
;1406:#define DP_S_CONV    7
;1407:#define DP_S_DONE    8
;1408:
;1409:/* format flags - Bits */
;1410:#define DP_F_MINUS  (1 << 0)
;1411:#define DP_F_PLUS   (1 << 1)
;1412:#define DP_F_SPACE  (1 << 2)
;1413:#define DP_F_NUM    (1 << 3)
;1414:#define DP_F_ZERO   (1 << 4)
;1415:#define DP_F_UP     (1 << 5)
;1416:#define DP_F_UNSIGNED  (1 << 6)
;1417:
;1418:/* Conversion Flags */
;1419:#define DP_C_SHORT   1
;1420:#define DP_C_LONG    2
;1421:#define DP_C_LLONG   3
;1422:#define DP_C_LDOUBLE 4
;1423:
;1424:#define char_to_int(p) (p - '0')
;1425:#define MAX(p,q) ((p >= q) ? p : q)
;1426:#define MIN(p,q) ((p <= q) ? p : q)
;1427:
;1428:static int dopr(char *buffer, size_t maxlen, const char *format, va_list args) {
line 1441
;1429:	char ch;
;1430:	LLONG value;
;1431:	LDOUBLE fvalue;
;1432:	char *strvalue;
;1433:	int min;
;1434:	int max;
;1435:	int state;
;1436:	int flags;
;1437:	int cflags;
;1438:	int total;
;1439:	size_t currlen;
;1440:
;1441:	state = DP_S_DEFAULT;
ADDRLP4 0
CNSTI4 0
ASGNI4
line 1442
;1442:	currlen = flags = cflags = min = 0;
ADDRLP4 44
CNSTI4 0
ASGNI4
ADDRLP4 16
ADDRLP4 44
INDIRI4
ASGNI4
ADDRLP4 12
ADDRLP4 44
INDIRI4
ASGNI4
ADDRLP4 20
ADDRLP4 44
INDIRI4
ASGNI4
ADDRLP4 28
ADDRLP4 44
INDIRI4
ASGNI4
line 1443
;1443:	max = -1;
ADDRLP4 8
CNSTI4 -1
ASGNI4
line 1444
;1444:	ch = *format++;
ADDRLP4 48
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 48
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 48
INDIRP4
INDIRI1
ASGNI1
line 1445
;1445:	total = 0;
ADDRLP4 24
CNSTI4 0
ASGNI4
ADDRGP4 $439
JUMPV
LABELV $438
line 1447
;1446:
;1447:	while (state != DP_S_DONE) {
line 1448
;1448:		if (ch == '\0')
ADDRLP4 4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $441
line 1449
;1449:			state = DP_S_DONE;
ADDRLP4 0
CNSTI4 8
ASGNI4
LABELV $441
line 1451
;1450:
;1451:		switch (state) {
ADDRLP4 0
INDIRI4
CNSTI4 0
LTI4 $444
ADDRLP4 0
INDIRI4
CNSTI4 8
GTI4 $444
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 $551
ADDP4
INDIRP4
JUMPV
lit
align 4
LABELV $551
address $445
address $448
address $458
address $463
address $466
address $473
address $484
address $489
address $444
code
LABELV $445
line 1453
;1452:			case DP_S_DEFAULT:
;1453:				if (ch == '%')
ADDRLP4 4
INDIRI1
CVII4 1
CNSTI4 37
NEI4 $446
line 1454
;1454:					state = DP_S_FLAGS;
ADDRLP4 0
CNSTI4 1
ASGNI4
ADDRGP4 $447
JUMPV
LABELV $446
line 1456
;1455:				else
;1456:					total += dopr_outch(buffer, &currlen, maxlen, ch);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 56
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 56
INDIRI4
ADDI4
ASGNI4
LABELV $447
line 1457
;1457:				ch = *format++;
ADDRLP4 60
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 60
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 60
INDIRP4
INDIRI1
ASGNI1
line 1458
;1458:				break;
ADDRGP4 $444
JUMPV
LABELV $448
line 1460
;1459:			case DP_S_FLAGS:
;1460:				switch (ch) {
ADDRLP4 64
ADDRLP4 4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 72
CNSTI4 32
ASGNI4
ADDRLP4 64
INDIRI4
ADDRLP4 72
INDIRI4
EQI4 $454
ADDRLP4 64
INDIRI4
CNSTI4 35
EQI4 $455
ADDRLP4 64
INDIRI4
ADDRLP4 72
INDIRI4
LTI4 $449
LABELV $457
ADDRLP4 64
INDIRI4
CNSTI4 43
EQI4 $453
ADDRLP4 64
INDIRI4
CNSTI4 45
EQI4 $452
ADDRLP4 64
INDIRI4
CNSTI4 48
EQI4 $456
ADDRGP4 $449
JUMPV
LABELV $452
line 1462
;1461:					case '-':
;1462:						flags |= DP_F_MINUS;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 1
BORI4
ASGNI4
line 1463
;1463:						ch = *format++;
ADDRLP4 80
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 80
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 80
INDIRP4
INDIRI1
ASGNI1
line 1464
;1464:						break;
ADDRGP4 $444
JUMPV
LABELV $453
line 1466
;1465:					case '+':
;1466:						flags |= DP_F_PLUS;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 2
BORI4
ASGNI4
line 1467
;1467:						ch = *format++;
ADDRLP4 84
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 84
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 84
INDIRP4
INDIRI1
ASGNI1
line 1468
;1468:						break;
ADDRGP4 $444
JUMPV
LABELV $454
line 1470
;1469:					case ' ':
;1470:						flags |= DP_F_SPACE;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 4
BORI4
ASGNI4
line 1471
;1471:						ch = *format++;
ADDRLP4 88
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 88
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 88
INDIRP4
INDIRI1
ASGNI1
line 1472
;1472:						break;
ADDRGP4 $444
JUMPV
LABELV $455
line 1474
;1473:					case '#':
;1474:						flags |= DP_F_NUM;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 8
BORI4
ASGNI4
line 1475
;1475:						ch = *format++;
ADDRLP4 92
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 92
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 92
INDIRP4
INDIRI1
ASGNI1
line 1476
;1476:						break;
ADDRGP4 $444
JUMPV
LABELV $456
line 1478
;1477:					case '0':
;1478:						flags |= DP_F_ZERO;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 16
BORI4
ASGNI4
line 1479
;1479:						ch = *format++;
ADDRLP4 96
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 96
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 96
INDIRP4
INDIRI1
ASGNI1
line 1480
;1480:						break;
ADDRGP4 $444
JUMPV
LABELV $449
line 1482
;1481:					default:
;1482:						state = DP_S_MIN;
ADDRLP4 0
CNSTI4 2
ASGNI4
line 1483
;1483:						break;
line 1485
;1484:				}
;1485:				break;
ADDRGP4 $444
JUMPV
LABELV $458
line 1487
;1486:			case DP_S_MIN:
;1487:				if ('0' <= ch && ch <= '9') {
ADDRLP4 80
ADDRLP4 4
INDIRI1
CVII4 1
ASGNI4
CNSTI4 48
ADDRLP4 80
INDIRI4
GTI4 $459
ADDRLP4 80
INDIRI4
CNSTI4 57
GTI4 $459
line 1488
;1488:					min = 10 * min + char_to_int(ch);
ADDRLP4 16
CNSTI4 10
ADDRLP4 16
INDIRI4
MULI4
ADDRLP4 4
INDIRI1
CVII4 1
CNSTI4 48
SUBI4
ADDI4
ASGNI4
line 1489
;1489:					ch = *format++;
ADDRLP4 84
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 84
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 84
INDIRP4
INDIRI1
ASGNI1
line 1490
;1490:				}
ADDRGP4 $444
JUMPV
LABELV $459
line 1491
;1491:				else if (ch == '*') {
ADDRLP4 4
INDIRI1
CVII4 1
CNSTI4 42
NEI4 $461
line 1492
;1492:					min = va_arg(args, int);
ADDRLP4 84
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 84
INDIRP4
ASGNP4
ADDRLP4 16
ADDRLP4 84
INDIRP4
CNSTI4 -4
ADDP4
INDIRI4
ASGNI4
line 1493
;1493:					ch = *format++;
ADDRLP4 88
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 88
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 88
INDIRP4
INDIRI1
ASGNI1
line 1494
;1494:					state = DP_S_DOT;
ADDRLP4 0
CNSTI4 3
ASGNI4
line 1495
;1495:				}
ADDRGP4 $444
JUMPV
LABELV $461
line 1497
;1496:				else
;1497:					state = DP_S_DOT;
ADDRLP4 0
CNSTI4 3
ASGNI4
line 1498
;1498:				break;
ADDRGP4 $444
JUMPV
LABELV $463
line 1500
;1499:			case DP_S_DOT:
;1500:				if (ch == '.') {
ADDRLP4 4
INDIRI1
CVII4 1
CNSTI4 46
NEI4 $464
line 1501
;1501:					state = DP_S_MAX;
ADDRLP4 0
CNSTI4 4
ASGNI4
line 1502
;1502:					ch = *format++;
ADDRLP4 84
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 84
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 84
INDIRP4
INDIRI1
ASGNI1
line 1503
;1503:				}
ADDRGP4 $444
JUMPV
LABELV $464
line 1505
;1504:				else
;1505:					state = DP_S_MOD;
ADDRLP4 0
CNSTI4 5
ASGNI4
line 1506
;1506:				break;
ADDRGP4 $444
JUMPV
LABELV $466
line 1508
;1507:			case DP_S_MAX:
;1508:				if ('0' <= ch && ch <= '9') {
ADDRLP4 84
ADDRLP4 4
INDIRI1
CVII4 1
ASGNI4
CNSTI4 48
ADDRLP4 84
INDIRI4
GTI4 $467
ADDRLP4 84
INDIRI4
CNSTI4 57
GTI4 $467
line 1509
;1509:					if (max < 0)
ADDRLP4 8
INDIRI4
CNSTI4 0
GEI4 $469
line 1510
;1510:						max = 0;
ADDRLP4 8
CNSTI4 0
ASGNI4
LABELV $469
line 1511
;1511:					max = 10 * max + char_to_int(ch);
ADDRLP4 8
CNSTI4 10
ADDRLP4 8
INDIRI4
MULI4
ADDRLP4 4
INDIRI1
CVII4 1
CNSTI4 48
SUBI4
ADDI4
ASGNI4
line 1512
;1512:					ch = *format++;
ADDRLP4 88
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 88
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 88
INDIRP4
INDIRI1
ASGNI1
line 1513
;1513:				}
ADDRGP4 $444
JUMPV
LABELV $467
line 1514
;1514:				else if (ch == '*') {
ADDRLP4 4
INDIRI1
CVII4 1
CNSTI4 42
NEI4 $471
line 1515
;1515:					max = va_arg(args, int);
ADDRLP4 88
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 88
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 88
INDIRP4
CNSTI4 -4
ADDP4
INDIRI4
ASGNI4
line 1516
;1516:					ch = *format++;
ADDRLP4 92
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 92
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 92
INDIRP4
INDIRI1
ASGNI1
line 1517
;1517:					state = DP_S_MOD;
ADDRLP4 0
CNSTI4 5
ASGNI4
line 1518
;1518:				}
ADDRGP4 $444
JUMPV
LABELV $471
line 1520
;1519:				else
;1520:					state = DP_S_MOD;
ADDRLP4 0
CNSTI4 5
ASGNI4
line 1521
;1521:				break;
ADDRGP4 $444
JUMPV
LABELV $473
line 1523
;1522:			case DP_S_MOD:
;1523:				switch (ch) {
ADDRLP4 88
ADDRLP4 4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 96
CNSTI4 104
ASGNI4
ADDRLP4 88
INDIRI4
ADDRLP4 96
INDIRI4
EQI4 $477
ADDRLP4 88
INDIRI4
ADDRLP4 96
INDIRI4
GTI4 $481
LABELV $480
ADDRLP4 88
INDIRI4
CNSTI4 76
EQI4 $479
ADDRGP4 $475
JUMPV
LABELV $481
ADDRLP4 88
INDIRI4
CNSTI4 108
EQI4 $478
ADDRGP4 $475
JUMPV
LABELV $477
line 1525
;1524:					case 'h':
;1525:						cflags = DP_C_SHORT;
ADDRLP4 12
CNSTI4 1
ASGNI4
line 1526
;1526:						ch = *format++;
ADDRLP4 100
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 100
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 100
INDIRP4
INDIRI1
ASGNI1
line 1527
;1527:						break;
ADDRGP4 $475
JUMPV
LABELV $478
line 1529
;1528:					case 'l':
;1529:						cflags = DP_C_LONG;
ADDRLP4 12
CNSTI4 2
ASGNI4
line 1530
;1530:						ch = *format++;
ADDRLP4 104
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 104
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 104
INDIRP4
INDIRI1
ASGNI1
line 1531
;1531:						break;
ADDRGP4 $475
JUMPV
LABELV $479
line 1533
;1532:					case 'L':
;1533:						cflags = DP_C_LDOUBLE;
ADDRLP4 12
CNSTI4 4
ASGNI4
line 1534
;1534:						ch = *format++;
ADDRLP4 108
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 108
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 108
INDIRP4
INDIRI1
ASGNI1
line 1535
;1535:						break;
line 1537
;1536:					default:
;1537:						break;
LABELV $475
line 1539
;1538:				}
;1539:				if (cflags != DP_C_LONG)
ADDRLP4 12
INDIRI4
CNSTI4 2
EQI4 $482
line 1540
;1540:					state = DP_S_CONV;
ADDRLP4 0
CNSTI4 7
ASGNI4
ADDRGP4 $444
JUMPV
LABELV $482
line 1542
;1541:				else
;1542:					state = DP_S_MOD_L;
ADDRLP4 0
CNSTI4 6
ASGNI4
line 1543
;1543:				break;
ADDRGP4 $444
JUMPV
LABELV $484
line 1545
;1544:			case DP_S_MOD_L:
;1545:				switch (ch) {
ADDRLP4 100
ADDRLP4 4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 100
INDIRI4
CNSTI4 108
EQI4 $488
ADDRGP4 $486
JUMPV
LABELV $488
line 1547
;1546:					case 'l':
;1547:						cflags = DP_C_LLONG;
ADDRLP4 12
CNSTI4 3
ASGNI4
line 1548
;1548:						ch = *format++;
ADDRLP4 104
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 104
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 104
INDIRP4
INDIRI1
ASGNI1
line 1549
;1549:						break;
line 1551
;1550:					default:
;1551:						break;
LABELV $486
line 1553
;1552:				}
;1553:				state = DP_S_CONV;
ADDRLP4 0
CNSTI4 7
ASGNI4
line 1554
;1554:				break;
ADDRGP4 $444
JUMPV
LABELV $489
line 1556
;1555:			case DP_S_CONV:
;1556:				switch (ch) {
ADDRLP4 104
ADDRLP4 4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 104
INDIRI4
CNSTI4 69
EQI4 $525
ADDRLP4 112
CNSTI4 71
ASGNI4
ADDRLP4 104
INDIRI4
ADDRLP4 112
INDIRI4
EQI4 $529
ADDRLP4 104
INDIRI4
ADDRLP4 112
INDIRI4
GTI4 $546
LABELV $545
ADDRLP4 104
INDIRI4
CNSTI4 37
EQI4 $543
ADDRGP4 $491
JUMPV
LABELV $546
ADDRLP4 120
CNSTI4 88
ASGNI4
ADDRLP4 104
INDIRI4
ADDRLP4 120
INDIRI4
EQI4 $514
ADDRLP4 104
INDIRI4
ADDRLP4 120
INDIRI4
LTI4 $491
LABELV $547
ADDRLP4 104
INDIRI4
CNSTI4 99
LTI4 $491
ADDRLP4 104
INDIRI4
CNSTI4 120
GTI4 $491
ADDRLP4 104
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 $548-396
ADDP4
INDIRP4
JUMPV
lit
align 4
LABELV $548
address $533
address $493
address $526
address $522
address $530
address $491
address $493
address $491
address $491
address $491
address $491
address $536
address $500
address $535
address $491
address $491
address $534
address $491
address $507
address $491
address $544
address $515
code
LABELV $493
line 1559
;1557:					case 'd':
;1558:					case 'i':
;1559:						if (cflags == DP_C_SHORT)
ADDRLP4 12
INDIRI4
CNSTI4 1
NEI4 $494
line 1560
;1560:							value = (short int) va_arg(args, int);
ADDRLP4 128
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 128
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 128
INDIRP4
CNSTI4 -4
ADDP4
INDIRI4
CVII2 4
CVII4 2
ASGNI4
ADDRGP4 $495
JUMPV
LABELV $494
line 1561
;1561:						else if (cflags == DP_C_LONG)
ADDRLP4 12
INDIRI4
CNSTI4 2
NEI4 $496
line 1562
;1562:							value = va_arg(args, long int);
ADDRLP4 132
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 132
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 132
INDIRP4
CNSTI4 -4
ADDP4
INDIRI4
ASGNI4
ADDRGP4 $497
JUMPV
LABELV $496
line 1563
;1563:						else if (cflags == DP_C_LLONG)
ADDRLP4 12
INDIRI4
CNSTI4 3
NEI4 $498
line 1564
;1564:							value = va_arg(args, LLONG);
ADDRLP4 136
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 136
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 136
INDIRP4
CNSTI4 -4
ADDP4
INDIRI4
ASGNI4
ADDRGP4 $499
JUMPV
LABELV $498
line 1566
;1565:						else
;1566:							value = va_arg(args, int);
ADDRLP4 140
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 140
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 140
INDIRP4
CNSTI4 -4
ADDP4
INDIRI4
ASGNI4
LABELV $499
LABELV $497
LABELV $495
line 1567
;1567:						total += fmtint(buffer, &currlen, maxlen, value, 10, min, max, flags);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 32
INDIRI4
ARGI4
CNSTI4 10
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 144
ADDRGP4 fmtint
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 144
INDIRI4
ADDI4
ASGNI4
line 1568
;1568:						break;
ADDRGP4 $491
JUMPV
LABELV $500
line 1570
;1569:					case 'o':
;1570:						flags |= DP_F_UNSIGNED;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 64
BORI4
ASGNI4
line 1571
;1571:						if (cflags == DP_C_SHORT)
ADDRLP4 12
INDIRI4
CNSTI4 1
NEI4 $501
line 1573
;1572:							//	  value = (unsigned short int) va_arg (args, unsigned short int); // Thilo: This does not work because the rcc compiler cannot do that cast correctly.
;1573:							value = va_arg(args, unsigned int) & ((1 << sizeof (unsigned short int) * 8) - 1); // Using this workaround instead.
ADDRLP4 148
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 148
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 148
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CNSTU4 65535
BANDU4
CVUI4 4
ASGNI4
ADDRGP4 $502
JUMPV
LABELV $501
line 1574
;1574:						else if (cflags == DP_C_LONG)
ADDRLP4 12
INDIRI4
CNSTI4 2
NEI4 $503
line 1575
;1575:							value = va_arg(args, unsigned long int);
ADDRLP4 152
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 152
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 152
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
ADDRGP4 $504
JUMPV
LABELV $503
line 1576
;1576:						else if (cflags == DP_C_LLONG)
ADDRLP4 12
INDIRI4
CNSTI4 3
NEI4 $505
line 1577
;1577:							value = va_arg(args, unsigned LLONG);
ADDRLP4 156
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 156
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 156
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
ADDRGP4 $506
JUMPV
LABELV $505
line 1579
;1578:						else
;1579:							value = va_arg(args, unsigned int);
ADDRLP4 160
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 160
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 160
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
LABELV $506
LABELV $504
LABELV $502
line 1580
;1580:						total += fmtint(buffer, &currlen, maxlen, value, 8, min, max, flags);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 32
INDIRI4
ARGI4
CNSTI4 8
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 164
ADDRGP4 fmtint
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 164
INDIRI4
ADDI4
ASGNI4
line 1581
;1581:						break;
ADDRGP4 $491
JUMPV
LABELV $507
line 1583
;1582:					case 'u':
;1583:						flags |= DP_F_UNSIGNED;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 64
BORI4
ASGNI4
line 1584
;1584:						if (cflags == DP_C_SHORT)
ADDRLP4 12
INDIRI4
CNSTI4 1
NEI4 $508
line 1585
;1585:							value = va_arg(args, unsigned int) & ((1 << sizeof (unsigned short int) * 8) - 1);
ADDRLP4 168
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 168
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 168
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CNSTU4 65535
BANDU4
CVUI4 4
ASGNI4
ADDRGP4 $509
JUMPV
LABELV $508
line 1586
;1586:						else if (cflags == DP_C_LONG)
ADDRLP4 12
INDIRI4
CNSTI4 2
NEI4 $510
line 1587
;1587:							value = va_arg(args, unsigned long int);
ADDRLP4 172
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 172
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 172
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
ADDRGP4 $511
JUMPV
LABELV $510
line 1588
;1588:						else if (cflags == DP_C_LLONG)
ADDRLP4 12
INDIRI4
CNSTI4 3
NEI4 $512
line 1589
;1589:							value = va_arg(args, unsigned LLONG);
ADDRLP4 176
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 176
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 176
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
ADDRGP4 $513
JUMPV
LABELV $512
line 1591
;1590:						else
;1591:							value = va_arg(args, unsigned int);
ADDRLP4 180
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 180
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 180
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
LABELV $513
LABELV $511
LABELV $509
line 1592
;1592:						total += fmtint(buffer, &currlen, maxlen, value, 10, min, max, flags);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 32
INDIRI4
ARGI4
CNSTI4 10
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 184
ADDRGP4 fmtint
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 184
INDIRI4
ADDI4
ASGNI4
line 1593
;1593:						break;
ADDRGP4 $491
JUMPV
LABELV $514
line 1595
;1594:					case 'X':
;1595:						flags |= DP_F_UP;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 32
BORI4
ASGNI4
LABELV $515
line 1597
;1596:					case 'x':
;1597:						flags |= DP_F_UNSIGNED;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 64
BORI4
ASGNI4
line 1598
;1598:						if (cflags == DP_C_SHORT)
ADDRLP4 12
INDIRI4
CNSTI4 1
NEI4 $516
line 1599
;1599:							value = va_arg(args, unsigned int) & ((1 << sizeof (unsigned short int) * 8) - 1);
ADDRLP4 188
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 188
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 188
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CNSTU4 65535
BANDU4
CVUI4 4
ASGNI4
ADDRGP4 $517
JUMPV
LABELV $516
line 1600
;1600:						else if (cflags == DP_C_LONG)
ADDRLP4 12
INDIRI4
CNSTI4 2
NEI4 $518
line 1601
;1601:							value = va_arg(args, unsigned long int);
ADDRLP4 192
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 192
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 192
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
ADDRGP4 $519
JUMPV
LABELV $518
line 1602
;1602:						else if (cflags == DP_C_LLONG)
ADDRLP4 12
INDIRI4
CNSTI4 3
NEI4 $520
line 1603
;1603:							value = va_arg(args, unsigned LLONG);
ADDRLP4 196
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 196
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 196
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
ADDRGP4 $521
JUMPV
LABELV $520
line 1605
;1604:						else
;1605:							value = va_arg(args, unsigned int);
ADDRLP4 200
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 200
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 200
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
LABELV $521
LABELV $519
LABELV $517
line 1606
;1606:						total += fmtint(buffer, &currlen, maxlen, value, 16, min, max, flags);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 32
INDIRI4
ARGI4
CNSTI4 16
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 204
ADDRGP4 fmtint
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 204
INDIRI4
ADDI4
ASGNI4
line 1607
;1607:						break;
ADDRGP4 $491
JUMPV
LABELV $522
line 1609
;1608:					case 'f':
;1609:						if (cflags == DP_C_LDOUBLE)
ADDRLP4 12
INDIRI4
CNSTI4 4
NEI4 $523
line 1610
;1610:							fvalue = va_arg(args, LDOUBLE);
ADDRLP4 208
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 208
INDIRP4
ASGNP4
ADDRLP4 36
ADDRLP4 208
INDIRP4
CNSTI4 -4
ADDP4
INDIRF4
ASGNF4
ADDRGP4 $524
JUMPV
LABELV $523
line 1612
;1611:						else
;1612:							fvalue = va_arg(args, double);
ADDRLP4 212
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 212
INDIRP4
ASGNP4
ADDRLP4 36
ADDRLP4 212
INDIRP4
CNSTI4 -4
ADDP4
INDIRF4
ASGNF4
LABELV $524
line 1614
;1613:						/* um, floating point? */
;1614:						total += fmtfp(buffer, &currlen, maxlen, fvalue, min, max, flags);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 36
INDIRF4
ARGF4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 216
ADDRGP4 fmtfp
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 216
INDIRI4
ADDI4
ASGNI4
line 1615
;1615:						break;
ADDRGP4 $491
JUMPV
LABELV $525
line 1617
;1616:					case 'E':
;1617:						flags |= DP_F_UP;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 32
BORI4
ASGNI4
LABELV $526
line 1619
;1618:					case 'e':
;1619:						if (cflags == DP_C_LDOUBLE)
ADDRLP4 12
INDIRI4
CNSTI4 4
NEI4 $527
line 1620
;1620:							fvalue = va_arg(args, LDOUBLE);
ADDRLP4 220
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 220
INDIRP4
ASGNP4
ADDRLP4 36
ADDRLP4 220
INDIRP4
CNSTI4 -4
ADDP4
INDIRF4
ASGNF4
ADDRGP4 $528
JUMPV
LABELV $527
line 1622
;1621:						else
;1622:							fvalue = va_arg(args, double);
ADDRLP4 224
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 224
INDIRP4
ASGNP4
ADDRLP4 36
ADDRLP4 224
INDIRP4
CNSTI4 -4
ADDP4
INDIRF4
ASGNF4
LABELV $528
line 1624
;1623:						/* um, floating point? */
;1624:						total += fmtfp(buffer, &currlen, maxlen, fvalue, min, max, flags);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 36
INDIRF4
ARGF4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 228
ADDRGP4 fmtfp
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 228
INDIRI4
ADDI4
ASGNI4
line 1625
;1625:						break;
ADDRGP4 $491
JUMPV
LABELV $529
line 1627
;1626:					case 'G':
;1627:						flags |= DP_F_UP;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 32
BORI4
ASGNI4
LABELV $530
line 1629
;1628:					case 'g':
;1629:						if (cflags == DP_C_LDOUBLE)
ADDRLP4 12
INDIRI4
CNSTI4 4
NEI4 $531
line 1630
;1630:							fvalue = va_arg(args, LDOUBLE);
ADDRLP4 232
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 232
INDIRP4
ASGNP4
ADDRLP4 36
ADDRLP4 232
INDIRP4
CNSTI4 -4
ADDP4
INDIRF4
ASGNF4
ADDRGP4 $532
JUMPV
LABELV $531
line 1632
;1631:						else
;1632:							fvalue = va_arg(args, double);
ADDRLP4 236
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 236
INDIRP4
ASGNP4
ADDRLP4 36
ADDRLP4 236
INDIRP4
CNSTI4 -4
ADDP4
INDIRF4
ASGNF4
LABELV $532
line 1634
;1633:						/* um, floating point? */
;1634:						total += fmtfp(buffer, &currlen, maxlen, fvalue, min, max, flags);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 36
INDIRF4
ARGF4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 240
ADDRGP4 fmtfp
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 240
INDIRI4
ADDI4
ASGNI4
line 1635
;1635:						break;
ADDRGP4 $491
JUMPV
LABELV $533
line 1637
;1636:					case 'c':
;1637:						total += dopr_outch(buffer, &currlen, maxlen, va_arg(args, int));
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 244
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 244
INDIRP4
ASGNP4
ADDRLP4 244
INDIRP4
CNSTI4 -4
ADDP4
INDIRI4
CVII1 4
CVII4 1
ARGI4
ADDRLP4 248
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 248
INDIRI4
ADDI4
ASGNI4
line 1638
;1638:						break;
ADDRGP4 $491
JUMPV
LABELV $534
line 1640
;1639:					case 's':
;1640:						strvalue = va_arg(args, char *);
ADDRLP4 252
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 252
INDIRP4
ASGNP4
ADDRLP4 40
ADDRLP4 252
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ASGNP4
line 1641
;1641:						total += fmtstr(buffer, &currlen, maxlen, strvalue, flags, min, max);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 40
INDIRP4
ARGP4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 256
ADDRGP4 fmtstr
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 256
INDIRI4
ADDI4
ASGNI4
line 1642
;1642:						break;
ADDRGP4 $491
JUMPV
LABELV $535
line 1644
;1643:					case 'p':
;1644:						strvalue = va_arg(args, void *);
ADDRLP4 260
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 260
INDIRP4
ASGNP4
ADDRLP4 40
ADDRLP4 260
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ASGNP4
line 1645
;1645:						total += fmtint(buffer, &currlen, maxlen, (long) strvalue, 16, min,
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 40
INDIRP4
CVPU4 4
CVUI4 4
ARGI4
CNSTI4 16
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 264
ADDRGP4 fmtint
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 264
INDIRI4
ADDI4
ASGNI4
line 1647
;1646:								max, flags);
;1647:						break;
ADDRGP4 $491
JUMPV
LABELV $536
line 1649
;1648:					case 'n':
;1649:						if (cflags == DP_C_SHORT) {
ADDRLP4 12
INDIRI4
CNSTI4 1
NEI4 $537
line 1651
;1650:							short int *num;
;1651:							num = va_arg(args, short int *);
ADDRLP4 272
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 272
INDIRP4
ASGNP4
ADDRLP4 268
ADDRLP4 272
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ASGNP4
line 1652
;1652:							*num = currlen;
ADDRLP4 268
INDIRP4
ADDRLP4 28
INDIRI4
CVII2 4
ASGNI2
line 1653
;1653:						} else if (cflags == DP_C_LONG) {
ADDRGP4 $491
JUMPV
LABELV $537
ADDRLP4 12
INDIRI4
CNSTI4 2
NEI4 $539
line 1655
;1654:							long int *num;
;1655:							num = va_arg(args, long int *);
ADDRLP4 272
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 272
INDIRP4
ASGNP4
ADDRLP4 268
ADDRLP4 272
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ASGNP4
line 1656
;1656:							*num = currlen;
ADDRLP4 268
INDIRP4
ADDRLP4 28
INDIRI4
ASGNI4
line 1657
;1657:						}
ADDRGP4 $491
JUMPV
LABELV $539
line 1658
;1658:						else if (cflags == DP_C_LLONG) {
ADDRLP4 12
INDIRI4
CNSTI4 3
NEI4 $541
line 1660
;1659:							LLONG *num;
;1660:							num = va_arg(args, LLONG *);
ADDRLP4 272
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 272
INDIRP4
ASGNP4
ADDRLP4 268
ADDRLP4 272
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ASGNP4
line 1661
;1661:							*num = currlen;
ADDRLP4 268
INDIRP4
ADDRLP4 28
INDIRI4
ASGNI4
line 1662
;1662:						}
ADDRGP4 $491
JUMPV
LABELV $541
line 1663
;1663:						else {
line 1665
;1664:							int *num;
;1665:							num = va_arg(args, int *);
ADDRLP4 272
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 272
INDIRP4
ASGNP4
ADDRLP4 268
ADDRLP4 272
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ASGNP4
line 1666
;1666:							*num = currlen;
ADDRLP4 268
INDIRP4
ADDRLP4 28
INDIRI4
ASGNI4
line 1667
;1667:						}
line 1668
;1668:						break;
ADDRGP4 $491
JUMPV
LABELV $543
line 1670
;1669:					case '%':
;1670:						total += dopr_outch(buffer, &currlen, maxlen, ch);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 268
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 268
INDIRI4
ADDI4
ASGNI4
line 1671
;1671:						break;
ADDRGP4 $491
JUMPV
LABELV $544
line 1674
;1672:					case 'w':
;1673:						/* not supported yet, treat as next char */
;1674:						ch = *format++;
ADDRLP4 272
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 272
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 272
INDIRP4
INDIRI1
ASGNI1
line 1675
;1675:						break;
line 1678
;1676:					default:
;1677:						/* Unknown, skip */
;1678:						break;
LABELV $491
line 1680
;1679:				}
;1680:				ch = *format++;
ADDRLP4 128
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 128
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 128
INDIRP4
INDIRI1
ASGNI1
line 1681
;1681:				state = DP_S_DEFAULT;
ADDRLP4 0
CNSTI4 0
ASGNI4
line 1682
;1682:				flags = cflags = min = 0;
ADDRLP4 132
CNSTI4 0
ASGNI4
ADDRLP4 16
ADDRLP4 132
INDIRI4
ASGNI4
ADDRLP4 12
ADDRLP4 132
INDIRI4
ASGNI4
ADDRLP4 20
ADDRLP4 132
INDIRI4
ASGNI4
line 1683
;1683:				max = -1;
ADDRLP4 8
CNSTI4 -1
ASGNI4
line 1684
;1684:				break;
line 1686
;1685:			case DP_S_DONE:
;1686:				break;
line 1689
;1687:			default:
;1688:				/* hmm? */
;1689:				break; /* some picky compilers need this */
LABELV $444
line 1691
;1690:		}
;1691:	}
LABELV $439
line 1447
ADDRLP4 0
INDIRI4
CNSTI4 8
NEI4 $438
line 1692
;1692:	if (buffer != NULL) {
ADDRFP4 0
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $552
line 1693
;1693:		if (currlen < maxlen - 1)
ADDRLP4 28
INDIRI4
ADDRFP4 4
INDIRI4
CNSTI4 1
SUBI4
GEI4 $554
line 1694
;1694:			buffer[currlen] = '\0';
ADDRLP4 28
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
CNSTI1 0
ASGNI1
ADDRGP4 $555
JUMPV
LABELV $554
line 1696
;1695:		else
;1696:			buffer[maxlen - 1] = '\0';
ADDRFP4 4
INDIRI4
CNSTI4 1
SUBI4
ADDRFP4 0
INDIRP4
ADDP4
CNSTI1 0
ASGNI1
LABELV $555
line 1697
;1697:	}
LABELV $552
line 1698
;1698:	return total;
ADDRLP4 24
INDIRI4
RETI4
LABELV $437
endproc dopr 276 32
proc fmtstr 32 16
line 1702
;1699:}
;1700:
;1701:static int fmtstr(char *buffer, size_t *currlen, size_t maxlen,
;1702:		char *value, int flags, int min, int max) {
line 1704
;1703:	int padlen, strln; /* amount to pad */
;1704:	int cnt = 0;
ADDRLP4 12
CNSTI4 0
ASGNI4
line 1705
;1705:	int total = 0;
ADDRLP4 4
CNSTI4 0
ASGNI4
line 1707
;1706:
;1707:	if (value == 0) {
ADDRFP4 12
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $557
line 1708
;1708:		value = "<NULL>";
ADDRFP4 12
ADDRGP4 $559
ASGNP4
line 1709
;1709:	}
LABELV $557
line 1711
;1710:
;1711:	for (strln = 0; value[strln]; ++strln); /* strlen */
ADDRLP4 8
CNSTI4 0
ASGNI4
ADDRGP4 $563
JUMPV
LABELV $560
LABELV $561
ADDRLP4 8
ADDRLP4 8
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $563
ADDRLP4 8
INDIRI4
ADDRFP4 12
INDIRP4
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $560
line 1712
;1712:	if (max >= 0 && max < strln)
ADDRLP4 16
ADDRFP4 24
INDIRI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
LTI4 $564
ADDRLP4 16
INDIRI4
ADDRLP4 8
INDIRI4
GEI4 $564
line 1713
;1713:		strln = max;
ADDRLP4 8
ADDRFP4 24
INDIRI4
ASGNI4
LABELV $564
line 1714
;1714:	padlen = min - strln;
ADDRLP4 0
ADDRFP4 20
INDIRI4
ADDRLP4 8
INDIRI4
SUBI4
ASGNI4
line 1715
;1715:	if (padlen < 0)
ADDRLP4 0
INDIRI4
CNSTI4 0
GEI4 $566
line 1716
;1716:		padlen = 0;
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $566
line 1717
;1717:	if (flags & DP_F_MINUS)
ADDRFP4 16
INDIRI4
CNSTI4 1
BANDI4
CNSTI4 0
EQI4 $571
line 1718
;1718:		padlen = -padlen; /* Left Justify */
ADDRLP4 0
ADDRLP4 0
INDIRI4
NEGI4
ASGNI4
ADDRGP4 $571
JUMPV
LABELV $570
line 1720
;1719:
;1720:	while (padlen > 0) {
line 1721
;1721:		total += dopr_outch(buffer, currlen, maxlen, ' ');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 32
ARGI4
ADDRLP4 20
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 20
INDIRI4
ADDI4
ASGNI4
line 1722
;1722:		--padlen;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
line 1723
;1723:	}
LABELV $571
line 1720
ADDRLP4 0
INDIRI4
CNSTI4 0
GTI4 $570
ADDRGP4 $574
JUMPV
LABELV $573
line 1724
;1724:	while (*value && ((max < 0) || (cnt < max))) {
line 1725
;1725:		total += dopr_outch(buffer, currlen, maxlen, *value++);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 20
ADDRFP4 12
INDIRP4
ASGNP4
ADDRFP4 12
ADDRLP4 20
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 20
INDIRP4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 24
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 24
INDIRI4
ADDI4
ASGNI4
line 1726
;1726:		++cnt;
ADDRLP4 12
ADDRLP4 12
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1727
;1727:	}
LABELV $574
line 1724
ADDRLP4 20
CNSTI4 0
ASGNI4
ADDRFP4 12
INDIRP4
INDIRI1
CVII4 1
ADDRLP4 20
INDIRI4
EQI4 $576
ADDRLP4 24
ADDRFP4 24
INDIRI4
ASGNI4
ADDRLP4 24
INDIRI4
ADDRLP4 20
INDIRI4
LTI4 $573
ADDRLP4 12
INDIRI4
ADDRLP4 24
INDIRI4
LTI4 $573
LABELV $576
ADDRGP4 $578
JUMPV
LABELV $577
line 1728
;1728:	while (padlen < 0) {
line 1729
;1729:		total += dopr_outch(buffer, currlen, maxlen, ' ');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 32
ARGI4
ADDRLP4 28
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 28
INDIRI4
ADDI4
ASGNI4
line 1730
;1730:		++padlen;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1731
;1731:	}
LABELV $578
line 1728
ADDRLP4 0
INDIRI4
CNSTI4 0
LTI4 $577
line 1732
;1732:	return total;
ADDRLP4 4
INDIRI4
RETI4
LABELV $556
endproc fmtstr 32 16
proc fmtint 76 16
line 1738
;1733:}
;1734:
;1735:/* Have to handle DP_F_NUM (ie 0x and 0 alternates) */
;1736:
;1737:static int fmtint(char *buffer, size_t *currlen, size_t maxlen,
;1738:		LLONG value, int base, int min, int max, int flags) {
line 1739
;1739:	int signvalue = 0;
ADDRLP4 48
CNSTI4 0
ASGNI4
line 1742
;1740:	unsigned LLONG uvalue;
;1741:	char convert[24];
;1742:	int place = 0;
ADDRLP4 0
CNSTI4 0
ASGNI4
line 1743
;1743:	int spadlen = 0; /* amount to space pad */
ADDRLP4 4
CNSTI4 0
ASGNI4
line 1744
;1744:	int zpadlen = 0; /* amount to zero pad */
ADDRLP4 40
CNSTI4 0
ASGNI4
line 1746
;1745:	const char *digits;
;1746:	int total = 0;
ADDRLP4 12
CNSTI4 0
ASGNI4
line 1748
;1747:
;1748:	if (max < 0)
ADDRFP4 24
INDIRI4
CNSTI4 0
GEI4 $581
line 1749
;1749:		max = 0;
ADDRFP4 24
CNSTI4 0
ASGNI4
LABELV $581
line 1751
;1750:
;1751:	uvalue = value;
ADDRLP4 8
ADDRFP4 12
INDIRI4
CVIU4 4
ASGNU4
line 1753
;1752:
;1753:	if (!(flags & DP_F_UNSIGNED)) {
ADDRFP4 28
INDIRI4
CNSTI4 64
BANDI4
CNSTI4 0
NEI4 $583
line 1754
;1754:		if (value < 0) {
ADDRFP4 12
INDIRI4
CNSTI4 0
GEI4 $585
line 1755
;1755:			signvalue = '-';
ADDRLP4 48
CNSTI4 45
ASGNI4
line 1756
;1756:			uvalue = -value;
ADDRLP4 8
ADDRFP4 12
INDIRI4
NEGI4
CVIU4 4
ASGNU4
line 1757
;1757:		} else
ADDRGP4 $586
JUMPV
LABELV $585
line 1758
;1758:			if (flags & DP_F_PLUS) /* Do a sign (+/i) */
ADDRFP4 28
INDIRI4
CNSTI4 2
BANDI4
CNSTI4 0
EQI4 $587
line 1759
;1759:			signvalue = '+';
ADDRLP4 48
CNSTI4 43
ASGNI4
ADDRGP4 $588
JUMPV
LABELV $587
line 1761
;1760:		else
;1761:			if (flags & DP_F_SPACE)
ADDRFP4 28
INDIRI4
CNSTI4 4
BANDI4
CNSTI4 0
EQI4 $589
line 1762
;1762:			signvalue = ' ';
ADDRLP4 48
CNSTI4 32
ASGNI4
LABELV $589
LABELV $588
LABELV $586
line 1763
;1763:	}
LABELV $583
line 1765
;1764:
;1765:	if (flags & DP_F_UP)
ADDRFP4 28
INDIRI4
CNSTI4 32
BANDI4
CNSTI4 0
EQI4 $591
line 1767
;1766:		/* Should characters be upper case? */
;1767:		digits = "0123456789ABCDEF";
ADDRLP4 44
ADDRGP4 $593
ASGNP4
ADDRGP4 $592
JUMPV
LABELV $591
line 1769
;1768:	else
;1769:		digits = "0123456789abcdef";
ADDRLP4 44
ADDRGP4 $594
ASGNP4
LABELV $592
LABELV $595
line 1771
;1770:
;1771:	do {
line 1772
;1772:		convert[place++] = digits[uvalue % (unsigned) base];
ADDRLP4 52
ADDRLP4 0
INDIRI4
ASGNI4
ADDRLP4 0
ADDRLP4 52
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 52
INDIRI4
ADDRLP4 16
ADDP4
ADDRLP4 8
INDIRU4
ADDRFP4 16
INDIRI4
CVIU4 4
MODU4
ADDRLP4 44
INDIRP4
ADDP4
INDIRI1
ASGNI1
line 1773
;1773:		uvalue = (uvalue / (unsigned) base);
ADDRLP4 8
ADDRLP4 8
INDIRU4
ADDRFP4 16
INDIRI4
CVIU4 4
DIVU4
ASGNU4
line 1774
;1774:	} while (uvalue && (place < sizeof (convert)));
LABELV $596
ADDRLP4 8
INDIRU4
CNSTU4 0
EQU4 $598
ADDRLP4 0
INDIRI4
CVIU4 4
CNSTU4 24
LTU4 $595
LABELV $598
line 1775
;1775:	if (place == sizeof (convert)) place--;
ADDRLP4 0
INDIRI4
CVIU4 4
CNSTU4 24
NEU4 $599
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
LABELV $599
line 1776
;1776:	convert[place] = 0;
ADDRLP4 0
INDIRI4
ADDRLP4 16
ADDP4
CNSTI1 0
ASGNI1
line 1778
;1777:
;1778:	zpadlen = max - place;
ADDRLP4 40
ADDRFP4 24
INDIRI4
ADDRLP4 0
INDIRI4
SUBI4
ASGNI4
line 1779
;1779:	spadlen = min - MAX(max, place) - (signvalue ? 1 : 0);
ADDRFP4 24
INDIRI4
ADDRLP4 0
INDIRI4
LTI4 $603
ADDRLP4 52
ADDRFP4 24
INDIRI4
ASGNI4
ADDRGP4 $604
JUMPV
LABELV $603
ADDRLP4 52
ADDRLP4 0
INDIRI4
ASGNI4
LABELV $604
ADDRLP4 48
INDIRI4
CNSTI4 0
EQI4 $605
ADDRLP4 56
CNSTI4 1
ASGNI4
ADDRGP4 $606
JUMPV
LABELV $605
ADDRLP4 56
CNSTI4 0
ASGNI4
LABELV $606
ADDRLP4 4
ADDRFP4 20
INDIRI4
ADDRLP4 52
INDIRI4
SUBI4
ADDRLP4 56
INDIRI4
SUBI4
ASGNI4
line 1780
;1780:	if (zpadlen < 0) zpadlen = 0;
ADDRLP4 40
INDIRI4
CNSTI4 0
GEI4 $607
ADDRLP4 40
CNSTI4 0
ASGNI4
LABELV $607
line 1781
;1781:	if (spadlen < 0) spadlen = 0;
ADDRLP4 4
INDIRI4
CNSTI4 0
GEI4 $609
ADDRLP4 4
CNSTI4 0
ASGNI4
LABELV $609
line 1782
;1782:	if (flags & DP_F_ZERO) {
ADDRFP4 28
INDIRI4
CNSTI4 16
BANDI4
CNSTI4 0
EQI4 $611
line 1783
;1783:		zpadlen = MAX(zpadlen, spadlen);
ADDRLP4 40
INDIRI4
ADDRLP4 4
INDIRI4
LTI4 $614
ADDRLP4 60
ADDRLP4 40
INDIRI4
ASGNI4
ADDRGP4 $615
JUMPV
LABELV $614
ADDRLP4 60
ADDRLP4 4
INDIRI4
ASGNI4
LABELV $615
ADDRLP4 40
ADDRLP4 60
INDIRI4
ASGNI4
line 1784
;1784:		spadlen = 0;
ADDRLP4 4
CNSTI4 0
ASGNI4
line 1785
;1785:	}
LABELV $611
line 1786
;1786:	if (flags & DP_F_MINUS)
ADDRFP4 28
INDIRI4
CNSTI4 1
BANDI4
CNSTI4 0
EQI4 $619
line 1787
;1787:		spadlen = -spadlen; /* Left Justifty */
ADDRLP4 4
ADDRLP4 4
INDIRI4
NEGI4
ASGNI4
ADDRGP4 $619
JUMPV
LABELV $618
line 1795
;1788:
;1789:#ifdef DEBUG_SNPRINTF
;1790:	dprint(1, (debugfile, "zpad: %d, spad: %d, min: %d, max: %d, place: %d\n",
;1791:			zpadlen, spadlen, min, max, place));
;1792:#endif
;1793:
;1794:	/* Spaces */
;1795:	while (spadlen > 0) {
line 1796
;1796:		total += dopr_outch(buffer, currlen, maxlen, ' ');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 32
ARGI4
ADDRLP4 60
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 12
INDIRI4
ADDRLP4 60
INDIRI4
ADDI4
ASGNI4
line 1797
;1797:		--spadlen;
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
line 1798
;1798:	}
LABELV $619
line 1795
ADDRLP4 4
INDIRI4
CNSTI4 0
GTI4 $618
line 1801
;1799:
;1800:	/* Sign */
;1801:	if (signvalue)
ADDRLP4 48
INDIRI4
CNSTI4 0
EQI4 $621
line 1802
;1802:		total += dopr_outch(buffer, currlen, maxlen, signvalue);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 48
INDIRI4
CVII1 4
CVII4 1
ARGI4
ADDRLP4 60
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 12
INDIRI4
ADDRLP4 60
INDIRI4
ADDI4
ASGNI4
LABELV $621
line 1805
;1803:
;1804:	/* Zeros */
;1805:	if (zpadlen > 0) {
ADDRLP4 40
INDIRI4
CNSTI4 0
LEI4 $629
ADDRGP4 $626
JUMPV
LABELV $625
line 1806
;1806:		while (zpadlen > 0) {
line 1807
;1807:			total += dopr_outch(buffer, currlen, maxlen, '0');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 48
ARGI4
ADDRLP4 64
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 12
INDIRI4
ADDRLP4 64
INDIRI4
ADDI4
ASGNI4
line 1808
;1808:			--zpadlen;
ADDRLP4 40
ADDRLP4 40
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
line 1809
;1809:		}
LABELV $626
line 1806
ADDRLP4 40
INDIRI4
CNSTI4 0
GTI4 $625
line 1810
;1810:	}
ADDRGP4 $629
JUMPV
LABELV $628
line 1814
;1811:
;1812:	/* Digits */
;1813:	while (place > 0)
;1814:		total += dopr_outch(buffer, currlen, maxlen, convert[--place]);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 64
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRLP4 0
ADDRLP4 64
INDIRI4
ASGNI4
ADDRLP4 64
INDIRI4
ADDRLP4 16
ADDP4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 68
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 12
INDIRI4
ADDRLP4 68
INDIRI4
ADDI4
ASGNI4
LABELV $629
line 1813
ADDRLP4 0
INDIRI4
CNSTI4 0
GTI4 $628
ADDRGP4 $632
JUMPV
LABELV $631
line 1817
;1815:
;1816:	/* Left Justified spaces */
;1817:	while (spadlen < 0) {
line 1818
;1818:		total += dopr_outch(buffer, currlen, maxlen, ' ');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 32
ARGI4
ADDRLP4 72
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 12
INDIRI4
ADDRLP4 72
INDIRI4
ADDI4
ASGNI4
line 1819
;1819:		++spadlen;
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1820
;1820:	}
LABELV $632
line 1817
ADDRLP4 4
INDIRI4
CNSTI4 0
LTI4 $631
line 1822
;1821:
;1822:	return total;
ADDRLP4 12
INDIRI4
RETI4
LABELV $580
endproc fmtint 76 16
proc abs_val 4 0
line 1825
;1823:}
;1824:
;1825:static LDOUBLE abs_val(LDOUBLE value) {
line 1826
;1826:	LDOUBLE result = value;
ADDRLP4 0
ADDRFP4 0
INDIRF4
ASGNF4
line 1828
;1827:
;1828:	if (value < 0)
ADDRFP4 0
INDIRF4
CNSTF4 0
GEF4 $635
line 1829
;1829:		result = -value;
ADDRLP4 0
ADDRFP4 0
INDIRF4
NEGF4
ASGNF4
LABELV $635
line 1831
;1830:
;1831:	return result;
ADDRLP4 0
INDIRF4
RETF4
LABELV $634
endproc abs_val 4 0
proc round 4 0
line 1834
;1832:}
;1833:
;1834:static long round(LDOUBLE value) {
line 1837
;1835:	long intpart;
;1836:
;1837:	intpart = value;
ADDRLP4 0
ADDRFP4 0
INDIRF4
CVFI4 4
ASGNI4
line 1838
;1838:	value = value - intpart;
ADDRFP4 0
ADDRFP4 0
INDIRF4
ADDRLP4 0
INDIRI4
CVIF4 4
SUBF4
ASGNF4
line 1839
;1839:	if (value >= 0.5)
ADDRFP4 0
INDIRF4
CNSTF4 1056964608
LTF4 $638
line 1840
;1840:		intpart++;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $638
line 1842
;1841:
;1842:	return intpart;
ADDRLP4 0
INDIRI4
RETI4
LABELV $637
endproc round 4 0
proc fmtfp 136 16
line 1846
;1843:}
;1844:
;1845:static int fmtfp(char *buffer, size_t *currlen, size_t maxlen,
;1846:		LDOUBLE fvalue, int min, int max, int flags) {
line 1847
;1847:	int signvalue = 0;
ADDRLP4 72
CNSTI4 0
ASGNI4
line 1851
;1848:	LDOUBLE ufvalue;
;1849:	char iconvert[20];
;1850:	char fconvert[20];
;1851:	int iplace = 0;
ADDRLP4 8
CNSTI4 0
ASGNI4
line 1852
;1852:	int fplace = 0;
ADDRLP4 20
CNSTI4 0
ASGNI4
line 1853
;1853:	int padlen = 0; /* amount to pad */
ADDRLP4 0
CNSTI4 0
ASGNI4
line 1854
;1854:	int zpadlen = 0;
ADDRLP4 68
CNSTI4 0
ASGNI4
line 1855
;1855:	int caps = 0;
ADDRLP4 44
CNSTI4 0
ASGNI4
line 1856
;1856:	int total = 0;
ADDRLP4 4
CNSTI4 0
ASGNI4
line 1864
;1857:	long intpart;
;1858:	long fracpart;
;1859:
;1860:	/* 
;1861:	 * AIX manpage says the default is 0, but Solaris says the default
;1862:	 * is 6, and sprintf on AIX defaults to 6
;1863:	 */
;1864:	if (max < 0)
ADDRFP4 20
INDIRI4
CNSTI4 0
GEI4 $641
line 1865
;1865:		max = 6;
ADDRFP4 20
CNSTI4 6
ASGNI4
LABELV $641
line 1867
;1866:
;1867:	ufvalue = abs_val(fvalue);
ADDRFP4 12
INDIRF4
ARGF4
ADDRLP4 80
ADDRGP4 abs_val
CALLF4
ASGNF4
ADDRLP4 76
ADDRLP4 80
INDIRF4
ASGNF4
line 1869
;1868:
;1869:	if (fvalue < 0)
ADDRFP4 12
INDIRF4
CNSTF4 0
GEF4 $643
line 1870
;1870:		signvalue = '-';
ADDRLP4 72
CNSTI4 45
ASGNI4
ADDRGP4 $644
JUMPV
LABELV $643
line 1872
;1871:	else
;1872:		if (flags & DP_F_PLUS) /* Do a sign (+/i) */
ADDRFP4 24
INDIRI4
CNSTI4 2
BANDI4
CNSTI4 0
EQI4 $645
line 1873
;1873:		signvalue = '+';
ADDRLP4 72
CNSTI4 43
ASGNI4
ADDRGP4 $646
JUMPV
LABELV $645
line 1875
;1874:	else
;1875:		if (flags & DP_F_SPACE)
ADDRFP4 24
INDIRI4
CNSTI4 4
BANDI4
CNSTI4 0
EQI4 $647
line 1876
;1876:		signvalue = ' ';
ADDRLP4 72
CNSTI4 32
ASGNI4
LABELV $647
LABELV $646
LABELV $644
line 1882
;1877:
;1878:#if 0
;1879:	if (flags & DP_F_UP) caps = 1; /* Should characters be upper case? */
;1880:#endif
;1881:
;1882:	intpart = ufvalue;
ADDRLP4 12
ADDRLP4 76
INDIRF4
CVFI4 4
ASGNI4
line 1888
;1883:
;1884:	/* 
;1885:	 * Sorry, we only support 9 digits past the decimal because of our 
;1886:	 * conversion method
;1887:	 */
;1888:	if (max > 9)
ADDRFP4 20
INDIRI4
CNSTI4 9
LEI4 $649
line 1889
;1889:		max = 9;
ADDRFP4 20
CNSTI4 9
ASGNI4
LABELV $649
line 1894
;1890:
;1891:	/* We "cheat" by converting the fractional part to integer by
;1892:	 * multiplying by a factor of 10
;1893:	 */
;1894:	fracpart = round((powN(10, max)) * (ufvalue - intpart));
CNSTF4 1092616192
ARGF4
ADDRFP4 20
INDIRI4
ARGI4
ADDRLP4 84
ADDRGP4 powN
CALLF4
ASGNF4
ADDRLP4 84
INDIRF4
ADDRLP4 76
INDIRF4
ADDRLP4 12
INDIRI4
CVIF4 4
SUBF4
MULF4
ARGF4
ADDRLP4 88
ADDRGP4 round
CALLI4
ASGNI4
ADDRLP4 16
ADDRLP4 88
INDIRI4
ASGNI4
line 1896
;1895:
;1896:	if (fracpart >= powN(10, max)) {
CNSTF4 1092616192
ARGF4
ADDRFP4 20
INDIRI4
ARGI4
ADDRLP4 92
ADDRGP4 powN
CALLF4
ASGNF4
ADDRLP4 16
INDIRI4
CVIF4 4
ADDRLP4 92
INDIRF4
LTF4 $651
line 1897
;1897:		intpart++;
ADDRLP4 12
ADDRLP4 12
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1898
;1898:		fracpart -= powN(10, max);
CNSTF4 1092616192
ARGF4
ADDRFP4 20
INDIRI4
ARGI4
ADDRLP4 96
ADDRGP4 powN
CALLF4
ASGNF4
ADDRLP4 16
ADDRLP4 16
INDIRI4
CVIF4 4
ADDRLP4 96
INDIRF4
SUBF4
CVFI4 4
ASGNI4
line 1899
;1899:	}
LABELV $651
LABELV $653
line 1906
;1900:
;1901:#ifdef DEBUG_SNPRINTF
;1902:	dprint(1, (debugfile, "fmtfp: %f =? %d.%d\n", fvalue, intpart, fracpart));
;1903:#endif
;1904:
;1905:	/* Convert integer part */
;1906:	do {
line 1907
;1907:		iconvert[iplace++] =
ADDRLP4 100
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
ADDRLP4 100
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 44
INDIRI4
CNSTI4 0
EQI4 $657
ADDRLP4 96
ADDRGP4 $593
ASGNP4
ADDRGP4 $658
JUMPV
LABELV $657
ADDRLP4 96
ADDRGP4 $594
ASGNP4
LABELV $658
ADDRLP4 100
INDIRI4
ADDRLP4 24
ADDP4
ADDRLP4 12
INDIRI4
CNSTI4 10
MODI4
ADDRLP4 96
INDIRP4
ADDP4
INDIRI1
ASGNI1
line 1909
;1908:				(caps ? "0123456789ABCDEF" : "0123456789abcdef")[intpart % 10];
;1909:		intpart = (intpart / 10);
ADDRLP4 12
ADDRLP4 12
INDIRI4
CNSTI4 10
DIVI4
ASGNI4
line 1910
;1910:	} while (intpart && (iplace < 20));
LABELV $654
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $659
ADDRLP4 8
INDIRI4
CNSTI4 20
LTI4 $653
LABELV $659
line 1911
;1911:	if (iplace == 20) iplace--;
ADDRLP4 8
INDIRI4
CNSTI4 20
NEI4 $660
ADDRLP4 8
ADDRLP4 8
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
LABELV $660
line 1912
;1912:	iconvert[iplace] = 0;
ADDRLP4 8
INDIRI4
ADDRLP4 24
ADDP4
CNSTI1 0
ASGNI1
LABELV $662
line 1915
;1913:
;1914:	/* Convert fractional part */
;1915:	do {
line 1916
;1916:		fconvert[fplace++] =
ADDRLP4 100
ADDRLP4 20
INDIRI4
ASGNI4
ADDRLP4 20
ADDRLP4 100
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 44
INDIRI4
CNSTI4 0
EQI4 $666
ADDRLP4 96
ADDRGP4 $593
ASGNP4
ADDRGP4 $667
JUMPV
LABELV $666
ADDRLP4 96
ADDRGP4 $594
ASGNP4
LABELV $667
ADDRLP4 100
INDIRI4
ADDRLP4 48
ADDP4
ADDRLP4 16
INDIRI4
CNSTI4 10
MODI4
ADDRLP4 96
INDIRP4
ADDP4
INDIRI1
ASGNI1
line 1918
;1917:				(caps ? "0123456789ABCDEF" : "0123456789abcdef")[fracpart % 10];
;1918:		fracpart = (fracpart / 10);
ADDRLP4 16
ADDRLP4 16
INDIRI4
CNSTI4 10
DIVI4
ASGNI4
line 1919
;1919:	} while (fracpart && (fplace < 20));
LABELV $663
ADDRLP4 16
INDIRI4
CNSTI4 0
EQI4 $668
ADDRLP4 20
INDIRI4
CNSTI4 20
LTI4 $662
LABELV $668
line 1920
;1920:	if (fplace == 20) fplace--;
ADDRLP4 20
INDIRI4
CNSTI4 20
NEI4 $669
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
LABELV $669
line 1921
;1921:	fconvert[fplace] = 0;
ADDRLP4 20
INDIRI4
ADDRLP4 48
ADDP4
CNSTI1 0
ASGNI1
line 1924
;1922:
;1923:	/* -1 for decimal point, another -1 if we are printing a sign */
;1924:	padlen = min - iplace - max - 1 - ((signvalue) ? 1 : 0);
ADDRLP4 72
INDIRI4
CNSTI4 0
EQI4 $672
ADDRLP4 96
CNSTI4 1
ASGNI4
ADDRGP4 $673
JUMPV
LABELV $672
ADDRLP4 96
CNSTI4 0
ASGNI4
LABELV $673
ADDRLP4 0
ADDRFP4 16
INDIRI4
ADDRLP4 8
INDIRI4
SUBI4
ADDRFP4 20
INDIRI4
SUBI4
CNSTI4 1
SUBI4
ADDRLP4 96
INDIRI4
SUBI4
ASGNI4
line 1925
;1925:	zpadlen = max - fplace;
ADDRLP4 68
ADDRFP4 20
INDIRI4
ADDRLP4 20
INDIRI4
SUBI4
ASGNI4
line 1926
;1926:	if (zpadlen < 0)
ADDRLP4 68
INDIRI4
CNSTI4 0
GEI4 $674
line 1927
;1927:		zpadlen = 0;
ADDRLP4 68
CNSTI4 0
ASGNI4
LABELV $674
line 1928
;1928:	if (padlen < 0)
ADDRLP4 0
INDIRI4
CNSTI4 0
GEI4 $676
line 1929
;1929:		padlen = 0;
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $676
line 1930
;1930:	if (flags & DP_F_MINUS)
ADDRFP4 24
INDIRI4
CNSTI4 1
BANDI4
CNSTI4 0
EQI4 $678
line 1931
;1931:		padlen = -padlen; /* Left Justifty */
ADDRLP4 0
ADDRLP4 0
INDIRI4
NEGI4
ASGNI4
LABELV $678
line 1933
;1932:
;1933:	if ((flags & DP_F_ZERO) && (padlen > 0)) {
ADDRLP4 100
CNSTI4 0
ASGNI4
ADDRFP4 24
INDIRI4
CNSTI4 16
BANDI4
ADDRLP4 100
INDIRI4
EQI4 $688
ADDRLP4 0
INDIRI4
ADDRLP4 100
INDIRI4
LEI4 $688
line 1934
;1934:		if (signvalue) {
ADDRLP4 72
INDIRI4
CNSTI4 0
EQI4 $685
line 1935
;1935:			total += dopr_outch(buffer, currlen, maxlen, signvalue);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 72
INDIRI4
CVII1 4
CVII4 1
ARGI4
ADDRLP4 104
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 104
INDIRI4
ADDI4
ASGNI4
line 1936
;1936:			--padlen;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
line 1937
;1937:			signvalue = 0;
ADDRLP4 72
CNSTI4 0
ASGNI4
line 1938
;1938:		}
ADDRGP4 $685
JUMPV
LABELV $684
line 1939
;1939:		while (padlen > 0) {
line 1940
;1940:			total += dopr_outch(buffer, currlen, maxlen, '0');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 48
ARGI4
ADDRLP4 104
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 104
INDIRI4
ADDI4
ASGNI4
line 1941
;1941:			--padlen;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
line 1942
;1942:		}
LABELV $685
line 1939
ADDRLP4 0
INDIRI4
CNSTI4 0
GTI4 $684
line 1943
;1943:	}
ADDRGP4 $688
JUMPV
LABELV $687
line 1944
;1944:	while (padlen > 0) {
line 1945
;1945:		total += dopr_outch(buffer, currlen, maxlen, ' ');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 32
ARGI4
ADDRLP4 104
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 104
INDIRI4
ADDI4
ASGNI4
line 1946
;1946:		--padlen;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
line 1947
;1947:	}
LABELV $688
line 1944
ADDRLP4 0
INDIRI4
CNSTI4 0
GTI4 $687
line 1948
;1948:	if (signvalue)
ADDRLP4 72
INDIRI4
CNSTI4 0
EQI4 $693
line 1949
;1949:		total += dopr_outch(buffer, currlen, maxlen, signvalue);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 72
INDIRI4
CVII1 4
CVII4 1
ARGI4
ADDRLP4 104
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 104
INDIRI4
ADDI4
ASGNI4
ADDRGP4 $693
JUMPV
LABELV $692
line 1952
;1950:
;1951:	while (iplace > 0)
;1952:		total += dopr_outch(buffer, currlen, maxlen, iconvert[--iplace]);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 108
ADDRLP4 8
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRLP4 8
ADDRLP4 108
INDIRI4
ASGNI4
ADDRLP4 108
INDIRI4
ADDRLP4 24
ADDP4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 112
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 112
INDIRI4
ADDI4
ASGNI4
LABELV $693
line 1951
ADDRLP4 8
INDIRI4
CNSTI4 0
GTI4 $692
line 1958
;1953:
;1954:	/*
;1955:	 * Decimal point.  This should probably use locale to find the correct
;1956:	 * char to print out.
;1957:	 */
;1958:	if (max > 0) {
ADDRFP4 20
INDIRI4
CNSTI4 0
LEI4 $704
line 1959
;1959:		total += dopr_outch(buffer, currlen, maxlen, '.');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 46
ARGI4
ADDRLP4 116
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 116
INDIRI4
ADDI4
ASGNI4
ADDRGP4 $698
JUMPV
LABELV $697
line 1962
;1960:
;1961:		while (zpadlen-- > 0)
;1962:			total += dopr_outch(buffer, currlen, maxlen, '0');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 48
ARGI4
ADDRLP4 120
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 120
INDIRI4
ADDI4
ASGNI4
LABELV $698
line 1961
ADDRLP4 124
ADDRLP4 68
INDIRI4
ASGNI4
ADDRLP4 68
ADDRLP4 124
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRLP4 124
INDIRI4
CNSTI4 0
GTI4 $697
ADDRGP4 $701
JUMPV
LABELV $700
line 1965
;1963:
;1964:		while (fplace > 0)
;1965:			total += dopr_outch(buffer, currlen, maxlen, fconvert[--fplace]);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 128
ADDRLP4 20
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRLP4 20
ADDRLP4 128
INDIRI4
ASGNI4
ADDRLP4 128
INDIRI4
ADDRLP4 48
ADDP4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 132
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 132
INDIRI4
ADDI4
ASGNI4
LABELV $701
line 1964
ADDRLP4 20
INDIRI4
CNSTI4 0
GTI4 $700
line 1966
;1966:	}
ADDRGP4 $704
JUMPV
LABELV $703
line 1968
;1967:
;1968:	while (padlen < 0) {
line 1969
;1969:		total += dopr_outch(buffer, currlen, maxlen, ' ');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 32
ARGI4
ADDRLP4 116
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 116
INDIRI4
ADDI4
ASGNI4
line 1970
;1970:		++padlen;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1971
;1971:	}
LABELV $704
line 1968
ADDRLP4 0
INDIRI4
CNSTI4 0
LTI4 $703
line 1973
;1972:
;1973:	return total;
ADDRLP4 4
INDIRI4
RETI4
LABELV $640
endproc fmtfp 136 16
proc dopr_outch 8 0
ADDRFP4 12
ADDRFP4 12
INDIRI4
CVII1 4
ASGNI1
line 1976
;1974:}
;1975:
;1976:static int dopr_outch(char *buffer, size_t *currlen, size_t maxlen, char c) {
line 1977
;1977:	if (*currlen + 1 < maxlen)
ADDRFP4 4
INDIRP4
INDIRI4
CNSTI4 1
ADDI4
ADDRFP4 8
INDIRI4
GEI4 $707
line 1978
;1978:		buffer[(*currlen)++] = c;
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 4
INDIRP4
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRFP4 12
INDIRI1
ASGNI1
LABELV $707
line 1979
;1979:	return 1;
CNSTI4 1
RETI4
LABELV $706
endproc dopr_outch 8 0
export Q_vsnprintf
proc Q_vsnprintf 4 16
line 1982
;1980:}
;1981:
;1982:int Q_vsnprintf(char *str, size_t length, const char *fmt, va_list args) {
line 1983
;1983:	if (str != NULL)
ADDRFP4 0
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $710
line 1984
;1984:		str[0] = 0;
ADDRFP4 0
INDIRP4
CNSTI1 0
ASGNI1
LABELV $710
line 1985
;1985:	return dopr(str, length, fmt, args);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRFP4 8
INDIRP4
ARGP4
ADDRFP4 12
INDIRP4
ARGP4
ADDRLP4 0
ADDRGP4 dopr
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
RETI4
LABELV $709
endproc Q_vsnprintf 4 16
export Q_snprintf
proc Q_snprintf 12 16
line 1988
;1986:}
;1987:
;1988:int Q_snprintf(char *str, size_t length, const char *fmt, ...) {
line 1992
;1989:	va_list ap;
;1990:	int retval;
;1991:
;1992:	va_start(ap, fmt);
ADDRLP4 0
ADDRFP4 8+4
ASGNP4
line 1993
;1993:	retval = Q_vsnprintf(str, length, fmt, ap);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 Q_vsnprintf
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 1994
;1994:	va_end(ap);
ADDRLP4 0
CNSTP4 0
ASGNP4
line 1996
;1995:
;1996:	return retval;
ADDRLP4 4
INDIRI4
RETI4
LABELV $712
endproc Q_snprintf 12 16
export sscanf
proc sscanf 88 4
line 2000
;1997:}
;1998:
;1999:/* this is really crappy */
;2000:int sscanf(const char *buffer, const char *fmt, ...) {
line 2006
;2001:	int cmd;
;2002:	va_list ap;
;2003:	int count;
;2004:	size_t len;
;2005:
;2006:	va_start(ap, fmt);
ADDRLP4 8
ADDRFP4 4+4
ASGNP4
line 2007
;2007:	count = 0;
ADDRLP4 12
CNSTI4 0
ASGNI4
ADDRGP4 $717
JUMPV
LABELV $716
line 2009
;2008:
;2009:	while (*fmt) {
line 2010
;2010:		if (fmt[0] != '%') {
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 37
EQI4 $719
line 2011
;2011:			fmt++;
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 2012
;2012:			continue;
ADDRGP4 $717
JUMPV
LABELV $719
line 2015
;2013:		}
;2014:
;2015:		fmt++;
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 2016
;2016:		cmd = *fmt;
ADDRLP4 0
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 2018
;2017:
;2018:		if (isdigit(cmd)) {
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $721
ADDRLP4 0
INDIRI4
CNSTI4 57
GTI4 $721
line 2019
;2019:			len = (size_t) _atoi(&fmt);
ADDRFP4 4
ARGP4
ADDRLP4 20
ADDRGP4 _atoi
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 20
INDIRI4
ASGNI4
line 2020
;2020:			cmd = *(fmt - 1);
ADDRLP4 0
ADDRFP4 4
INDIRP4
CNSTI4 -1
ADDP4
INDIRI1
CVII4 1
ASGNI4
line 2021
;2021:		} else {
ADDRGP4 $722
JUMPV
LABELV $721
line 2022
;2022:			len = MAX_STRING_CHARS - 1;
ADDRLP4 4
CNSTI4 1023
ASGNI4
line 2023
;2023:			fmt++;
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 2024
;2024:		}
LABELV $722
line 2026
;2025:
;2026:		switch (cmd) {
ADDRLP4 24
CNSTI4 100
ASGNI4
ADDRLP4 0
INDIRI4
ADDRLP4 24
INDIRI4
EQI4 $725
ADDRLP4 0
INDIRI4
CNSTI4 102
EQI4 $726
ADDRLP4 0
INDIRI4
CNSTI4 105
EQI4 $725
ADDRLP4 0
INDIRI4
ADDRLP4 24
INDIRI4
LTI4 $723
LABELV $736
ADDRLP4 0
INDIRI4
CNSTI4 115
EQI4 $727
ADDRLP4 0
INDIRI4
CNSTI4 117
EQI4 $725
ADDRGP4 $723
JUMPV
LABELV $725
line 2030
;2027:			case 'i':
;2028:			case 'd':
;2029:			case 'u':
;2030:				*(va_arg(ap, int *)) = _atoi(&buffer);
ADDRLP4 32
ADDRLP4 8
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRLP4 8
ADDRLP4 32
INDIRP4
ASGNP4
ADDRFP4 0
ARGP4
ADDRLP4 36
ADDRGP4 _atoi
CALLI4
ASGNI4
ADDRLP4 32
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ADDRLP4 36
INDIRI4
ASGNI4
line 2031
;2031:				break;
ADDRGP4 $724
JUMPV
LABELV $726
line 2033
;2032:			case 'f':
;2033:				*(va_arg(ap, float *)) = _atof(&buffer);
ADDRLP4 40
ADDRLP4 8
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRLP4 8
ADDRLP4 40
INDIRP4
ASGNP4
ADDRFP4 0
ARGP4
ADDRLP4 44
ADDRGP4 _atof
CALLF4
ASGNF4
ADDRLP4 40
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ADDRLP4 44
INDIRF4
ASGNF4
line 2034
;2034:				break;
ADDRGP4 $724
JUMPV
LABELV $727
line 2036
;2035:			case 's':
;2036:			{
line 2037
;2037:				char *s = va_arg(ap, char *);
ADDRLP4 52
ADDRLP4 8
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRLP4 8
ADDRLP4 52
INDIRP4
ASGNP4
ADDRLP4 48
ADDRLP4 52
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ASGNP4
ADDRGP4 $729
JUMPV
LABELV $728
line 2039
;2038:				while (isspace(*buffer))
;2039:					buffer++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $729
line 2038
ADDRLP4 56
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 56
INDIRI4
CNSTI4 32
EQI4 $728
ADDRLP4 56
INDIRI4
CNSTI4 12
EQI4 $728
ADDRLP4 56
INDIRI4
CNSTI4 10
EQI4 $728
ADDRLP4 56
INDIRI4
CNSTI4 13
EQI4 $728
ADDRLP4 56
INDIRI4
CNSTI4 9
EQI4 $728
ADDRLP4 56
INDIRI4
CNSTI4 11
EQI4 $728
ADDRGP4 $732
JUMPV
LABELV $731
line 2041
;2040:				while (*buffer && !isspace(*buffer) && len-- > 0)
;2041:					*s++ = *buffer++;
ADDRLP4 60
ADDRLP4 48
INDIRP4
ASGNP4
ADDRLP4 68
CNSTI4 1
ASGNI4
ADDRLP4 48
ADDRLP4 60
INDIRP4
ADDRLP4 68
INDIRI4
ADDP4
ASGNP4
ADDRLP4 64
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 64
INDIRP4
ADDRLP4 68
INDIRI4
ADDP4
ASGNP4
ADDRLP4 60
INDIRP4
ADDRLP4 64
INDIRP4
INDIRI1
ASGNI1
LABELV $732
line 2040
ADDRLP4 76
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 80
CNSTI4 0
ASGNI4
ADDRLP4 76
INDIRI4
ADDRLP4 80
INDIRI4
EQI4 $735
ADDRLP4 76
INDIRI4
CNSTI4 32
EQI4 $735
ADDRLP4 76
INDIRI4
CNSTI4 12
EQI4 $735
ADDRLP4 76
INDIRI4
CNSTI4 10
EQI4 $735
ADDRLP4 76
INDIRI4
CNSTI4 13
EQI4 $735
ADDRLP4 76
INDIRI4
CNSTI4 9
EQI4 $735
ADDRLP4 76
INDIRI4
CNSTI4 11
EQI4 $735
ADDRLP4 72
ADDRLP4 4
INDIRI4
ASGNI4
ADDRLP4 4
ADDRLP4 72
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRLP4 72
INDIRI4
ADDRLP4 80
INDIRI4
GTI4 $731
LABELV $735
line 2042
;2042:				*s++ = '\0';
ADDRLP4 84
ADDRLP4 48
INDIRP4
ASGNP4
ADDRLP4 48
ADDRLP4 84
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 84
INDIRP4
CNSTI1 0
ASGNI1
line 2043
;2043:				break;
LABELV $723
LABELV $724
line 2046
;2044:			}
;2045:		}
;2046:	}
LABELV $717
line 2009
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $716
line 2048
;2047:
;2048:	va_end(ap);
ADDRLP4 8
CNSTP4 0
ASGNP4
line 2049
;2049:	return count;
ADDRLP4 12
INDIRI4
RETI4
LABELV $714
endproc sscanf 88 4
import Com_Printf
import Com_Error
import Info_NextPair
import Info_Validate
import Info_SetValueForKey
import Info_RemoveKey_big
import Info_RemoveKey
import Info_ValueForKey
import Com_TruncateLongString
import va
import Q_CountChar
import Q_CleanStr
import Q_PrintStrlen
import Q_strcat
import Q_strncpyz
import Q_stristr
import Q_strupr
import Q_strlwr
import Q_stricmpn
import Q_strncmp
import Q_stricmp
import Q_isalpha
import Q_isupper
import Q_islower
import Q_isprint
import Q_StrToLower
import Com_RandomBytes
import Com_SkipCharset
import Com_SkipTokens
import Com_sprintf
import Parse3DMatrix
import Parse2DMatrix
import Parse1DMatrix
import SkipRestOfLine
import SkipBracedSection
import COM_MatchToken
import COM_ParseWarning
import COM_ParseError
import COM_Compress
import COM_ParseExt
import COM_Parse
import COM_GetCurrentParseLine
import COM_BeginParseSession
import COM_DefaultExtension
import COM_StripExtension
import COM_GetExtension
import COM_SkipPath
import Com_Clamp
import Q_isnan
import PerpendicularVector
import AngleVectors
import MatrixMultiply
import MakeNormalVectors
import RotateAroundDirection
import RotatePointAroundVector
import ProjectPointOnPlane
import PlaneFromPoints
import AngleDelta
import AngleNormalize180
import AngleNormalize360
import AnglesSubtract
import AngleSubtract
import LerpAngle
import AngleMod
import BoundsIntersectPoint
import BoundsIntersectSphere
import BoundsIntersect
import BoxOnPlaneSide
import SetPlaneSignbits
import AxisCopy
import AxisClear
import AnglesToAxis
import vectoangles
import Q_crandom
import Q_random
import Q_rand
import Q_acos
import Q_log2
import VectorRotate
import Vector4Scale
import VectorNormalize2
import VectorNormalize
import CrossProduct
import VectorInverse
import VectorNormalizeFast
import DistanceSquared
import Distance
import VectorLengthSquared
import VectorLength
import VectorCompare
import AddPointToBounds
import ClearBounds
import RadiusFromBounds
import NormalizeColor
import ColorBytes4
import ColorBytes3
import _VectorMA
import _VectorScale
import _VectorCopy
import _VectorAdd
import _VectorSubtract
import _DotProduct
import ByteToDir
import DirToByte
import ClampShort
import ClampChar
import Q_rsqrt
import Q_fabs
import axisDefault
import vec3_origin
import g_color_table
import colorDkGrey
import colorMdGrey
import colorLtGrey
import colorWhite
import colorCyan
import colorMagenta
import colorYellow
import colorBlue
import colorGreen
import colorRed
import colorBlack
import bytedirs
import Hunk_Alloc
import FloatSwap
import LongSwap
import ShortSwap
import acos
import atan2
import cos
import sin
import sqrt
import floor
import ceil
import memcpy
import memset
import strncpy
lit
align 1
LABELV $594
byte 1 48
byte 1 49
byte 1 50
byte 1 51
byte 1 52
byte 1 53
byte 1 54
byte 1 55
byte 1 56
byte 1 57
byte 1 97
byte 1 98
byte 1 99
byte 1 100
byte 1 101
byte 1 102
byte 1 0
align 1
LABELV $593
byte 1 48
byte 1 49
byte 1 50
byte 1 51
byte 1 52
byte 1 53
byte 1 54
byte 1 55
byte 1 56
byte 1 57
byte 1 65
byte 1 66
byte 1 67
byte 1 68
byte 1 69
byte 1 70
byte 1 0
align 1
LABELV $559
byte 1 60
byte 1 78
byte 1 85
byte 1 76
byte 1 76
byte 1 62
byte 1 0
align 1
LABELV $289
byte 1 48
byte 1 120
byte 1 0
align 1
LABELV $282
byte 1 105
byte 1 110
byte 1 105
byte 1 116
byte 1 121
byte 1 0
align 1
LABELV $277
byte 1 105
byte 1 110
byte 1 102
byte 1 0
align 1
LABELV $266
byte 1 110
byte 1 97
byte 1 110
byte 1 0
